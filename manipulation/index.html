<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - FBX loader</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
        <style type="text/css">
            body {
                background: radial-gradient(#cda381, #8b6a4e);
                margin:0;
            }
            .overlay {
                position:fixed;
                left:0;
                right:0;
                width:100vw;
                height:100vh;
                z-index:-100;
            }

            #blackout {
                background-color: black;
                display:none;
            }

            #content {
                display:none;
                z-index:0;
            }

            #controls {
                position:fixed;
                top:0;
                right:0;
                font-size:50px;
            }
            #controls div {
                margin:10px;
            }
            #fps{
                font-size:12pt;
            }

            #reset::after {
                content:"\01F501";
            } #playpause::after {
                content:"\023EF";
            } #wireframes::after {
                content:"\01F528"; 
            } #vr::after {
                content:"\01F3A5" ;
            } #text::after {
                content:"\01F4C3" ;
            } #info::after {
                content:"ðŸ’¾";
            } 

        </style>
    </head>

    <body>
        <div id="blackout" class="overlay">
        </div>
        <div id="content" class="overlay">
            <div style="width:100%; height:100%; background-color: #000000a5">
            </div>
            <div style="width:70vw;
                        min-width: 200px;
                        max-width:500px;
                        padding:50px;
                        background-color: white;
                        font-size:2rem;
                        position:absolute;
                        top: 50%;
                        left:50%;
                        -ms-transform: translateY(-50%) translateX(-50%);
                        transform: translateY(-50%) translateX(-50%);
                        filter: drop-shadow(0px 0px 20px #00000055);">
            <p>[H]ammering does not simply have knowledge about the hammerâ€™s character as equipment, but it has appropriated this equipment in a way that could not possibly be more suitable [...] [T]he less we just stare at the hammer-Thing, and the more we seize hold of it and use it, the more primordial does our relationship to it become, and the more unveiledly is it encountered as that which it is â€“ as equipment. The hammering itself uncovers the specific â€˜manipulabilityâ€™ of the hammer. The kind of Being which equipment possessesâ€“ in which it manifests itself in its own right â€“ we call readiness-to-hand.</p>

            <p>(Heidegger, 1927, 15:98)</p>
            </div>
        </div>
        <div id="controls">
            <div id="fps" style="display:none;">fps: 0</div>
            <div id="reset"></div>
            <div id="playpause" style="display:none;"></div>
            <div id="wireframes"></div>
            <div id="vr"></div>
            <div id="text"></div>
            <a href="UntitledToolAnalysis.pdf#toolbar=0&navpanes=0&scrollbar=0" style="text-decoration: none"><div id="info"></div></a>
        </div>

        <video id="video" loop muted crossOrigin="anonymous" playsinline style="display:none">
            <!-- <source src="textures/pano.webm"> -->
            <source src="textures/pano.mp4">
        </video>

        <!-- Worker script, will be run in separate thread -->
        <script id="worker1" type="module">
            var world;
            var hammerBody;
            var groundBody;
            var handBody;
            var hammerPivot;
            var hand = [];
            var lastPositions;
            var n_cubes;
            var indexConstraint, thumbConstraint, handConstraint, palmConstraint;
            var isGrasped = false;

            function bodyFromMesh(mesh, options) {
                options = options || {};
                body = new CANNON.Body(options);
                for(var i=0; i<mesh.length; i++) {
                    var verts=[], faces=[], norms=[];
                    // Get vertices
                    var vertices = mesh[i].vertices.array.values();
                    var normals = mesh[i].normals.array.values();
                    var count = 0;
                    var face = [0,0,0];
                    for (var j=0; j<mesh[i].vertices.count; j+=1) {
                        if (count % 3 == 0 && count !=0){
                            var idx = verts.length-1;
                            var testNorm = verts[idx-1].vsub(verts[idx-2]).cross(verts[idx].vsub(verts[idx-2]));
                            var n = norms[idx-2].dot(testNorm)
                            if(false){//n < 0){
                                faces.push(face[0], face[2], face[1])
                            }
                            else {
                                faces.push(face);
                            }
                        }
                        verts.push(new CANNON.Vec3(vertices.next().value,
                                                   vertices.next().value,
                                                   vertices.next().value));
                        norms.push(new CANNON.Vec3(normals.next().value,
                                                   normals.next().value,
                                                   normals.next().value));
                        face[count%3] = j%3;
                        count ++;
                    }
                    var bodyPart = new CANNON.ConvexPolyhedron(verts,faces);
                    body.addShape(bodyPart)
                }
                return body;
            }

            function resetBodies() {
                if (typeof palmConstraint !== 'undefined') {   
                    world.removeConstraint(palmConstraint);
                }
                // Everything but the floor and hand
                for(var i=1; i < n_cubes + 2; i++)
                {
                    // cubes
                    if(i < n_cubes+1)
                    {
                        world.bodies[i].position.set(Math.random()*.1-0.05,
                                                     Math.random()*.1-0.05,
                                                     0.25*(i+1)+0.05);
                    } else { // hammer
                        world.bodies[i].position.set(0.2,.1,0.1);
                        world.bodies[i].quaternion.set(0,-0.005,0,1);
                        world.bodies[i].quaternion.normalize();
                    }
                    world.bodies[i].velocity.set(0,0,0);
                    world.bodies[i].angularVelocity.set(0,0,0);
                    world.bodies[i].inertia.set(0,0,0);
                    world.bodies[i].vlambda.set(0,0,0);
                    world.bodies[i].wlambda.set(0,0,0);
                    if(hammerBody == world.bodies[i]) console.log(world.bodies[i]);
                    // world.bodies[i].updateInertiaWorld();
                    // world.bodies[i].updateMassProperties();
                    // world.bodies[i].updateSolveMassProperties();
                }
            }

            self.onmessage = function(e) {
                if(!e.data.bonePositions || !e.data.playAnim) {
                    var positions = e.data.positions;
                    var quaternions = e.data.quaternions;
                    self.postMessage({
                        positions:positions,
                        quaternions:quaternions
                    }, [(positions ? positions.buffer : []),
                        (positions ? quaternions.buffer : [])]);
                    return;
                }
                if (e.data.cannonUrl && !world) {
                    // Load cannon.js
                    importScripts(e.data.cannonUrl);

                    // Init physics
                    world = new CANNON.World();
                    world.broadphase = new CANNON.NaiveBroadphase();
                    world.narrowphase
                    world.gravity.set(0,0,-9.8);
                    // world.solver = new CANNON.SplitSolver(world.solver);
                    // world.defaultContactMaterial.contactEquationStiffness = 1e10;
                    // world.defaultContactMaterial.contactEquationRelaxation = 10;
                    // world.defaultContactMaterial.restitution = 0.1;
                    world.quatNormalizeFast = true;

                    // Ground plane
                    var plane = new CANNON.Plane();
                    groundBody = new CANNON.Body({ mass: 0 });
                    groundBody.addShape(plane);
                    // groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
                    groundBody.position.set(0,0,e.data.floorHeight);
                    world.addBody(groundBody);

                    // Create N cubes
                    var shape = new CANNON.Box(new CANNON.Vec3(0.05,0.05,0.05));
                    for(var i=0; i!==e.data.N; i++){
                        var body = new CANNON.Body({ mass: .1 });
                        body.addShape(shape);
                        world.addBody(body);
                    }

                    // Create hammer
                    hammerBody = bodyFromMesh(e.data.hammerMesh, {mass:0.5})
                    world.addBody(hammerBody)

                    n_cubes = e.data.N;
                    resetBodies();

                    // Create hand
                    for(var i=0; i < e.data.handMesh.length; i++){
                        var pos = new CANNON.Vec3(e.data.bonePositions[i * 3 + 0],
                                                  e.data.bonePositions[i * 3 + 1],
                                                  e.data.bonePositions[i * 3 + 2]);
                        var quat = new CANNON.Quaternion(e.data.boneQuaternions[i * 4 + 0],
                                                         e.data.boneQuaternions[i * 4 + 1],
                                                         e.data.boneQuaternions[i * 4 + 2],
                                                         e.data.boneQuaternions[i * 4 + 3]);
                        var mesh = bodyFromMesh(e.data.handMesh[i], {mass: 0,
                                                                     angularDamping:0,
                                                                     linearDamping:0,
                                                                     type: CANNON.Body.KINEMATIC,
                                                                     position: pos,
                                                                     quaternion: quat,
                                                                     collisionFilterGroup:2})
                        var name = e.data.handMesh[i][0].name
                        console.log("name: ", name);

                        if (name == "COL_Hand001") {
                            var centerA = new CANNON.Vec3(0,0,-.15);
                            var centerB = new CANNON.Vec3(0,-0.02220,0.027414);
                            indexConstraint = new CANNON.PointToPointConstraint(hammerBody, centerA, mesh, centerB,0.1)
                            world.addConstraint(indexConstraint);
                        }
                        if (name == "COL_Hand010") {
                            var centerA = new CANNON.Vec3(0,0,-.15);
                            var centerB = new CANNON.Vec3(-0.018637,0.002901,0.028293);
                            thumbConstraint = new CANNON.PointToPointConstraint(hammerBody, centerA, mesh, centerB,0.1)
                            world.addConstraint(thumbConstraint);
                        }
                        if (name == "COL_HammerPivot") {
                            hammerPivot = mesh;
                            mesh.collisionFilterGroup = 4;
                        }
                        // mesh.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
                        world.addBody(mesh);
                        // console.log(i,mesh)
                    };

                    // handBody = new CANNON.Body({ mass: 0.5,
                    //                              damping:0.6,
                    //                              collisionFilterGroup:8});
                    handBody = new CANNON.Body({ mass: 0,
                                                 type: CANNON.Body.KINEMATIC,
                                                 collisionFilterGroup:8});
                    handBody.addShape(new CANNON.Sphere(0.05));
                    world.addBody(handBody); 
                }

                if(e.data.hammerCanCollide && !e.data.isGrasped)
                    hammerBody.collisionFilterMask = 1|2;
                else
                    hammerBody.collisionFilterMask = 1;


                if(e.data.isPinched) {
                    indexConstraint.enable();
                    thumbConstraint.enable();
                } else {
                    indexConstraint.disable();
                    thumbConstraint.disable();
                }

                if(e.data.isGrasped) {
                    if(!isGrasped) {
                        if (typeof palmConstraint !== 'undefined') {   
                            world.removeConstraint(palmConstraint);
                        }
                        palmConstraint = new CANNON.LockConstraint(hammerBody, hammerPivot, 0.01);
                        palmConstraint.pivotA = new CANNON.Vec3(0,0,-.15/2);
                        world.addConstraint(palmConstraint);
                        palmConstraint.enable();
                    }
                    isGrasped = true;
                } else {
                    if (typeof palmConstraint !== 'undefined') {   
                        palmConstraint.disable();
                    }
                    isGrasped = false;
                }

                // Hand update
                for(var i=0; i<e.data.handIndices.length; i++){
                    // We don't need to update the hand. It's the first frame.
                    if(!lastPositions) {
                        continue;
                    }
                    var idx = e.data.handIndices[i]
                    // Rotation is set directly without angular velocity
                    var rot = [e.data.boneQuaternions[i * 4 + 0],
                               e.data.boneQuaternions[i * 4 + 1],
                               e.data.boneQuaternions[i * 4 + 2],
                               e.data.boneQuaternions[i * 4 + 3]];
                    world.bodies[idx].quaternion.set(rot[0], rot[1], rot[2], rot[3]);
                    // Position is applied via velocity
                    var vel = [(e.data.bonePositions[i * 3 + 0] - world.bodies[idx].position.x) / e.data.dt,
                               (e.data.bonePositions[i * 3 + 1] - world.bodies[idx].position.y) / e.data.dt,
                               (e.data.bonePositions[i * 3 + 2] - world.bodies[idx].position.z) / e.data.dt]
                    world.bodies[idx].velocity.set(vel[0], vel[1], vel[2]);
                }

                var handPos = new CANNON.Vec3(e.data.handPos[0],
                                              e.data.handPos[1],
                                              e.data.handPos[2]);

                handBody.quaternion.set(e.data.handRot[0],
                                        e.data.handRot[1],
                                        e.data.handRot[2],
                                        e.data.handRot[3]);

                diff = handPos.vsub(handBody.position).scale(1 / e.data.dt);
                handBody.velocity.set(diff.x, diff.y, diff.z);

                if(isGrasped){
                    hammerBody.velocity.set(diff.x, diff.y, diff.z);
                }

                lastPositions = [...e.data.bonePositions];
                
                if(e.data.reset) {
                    resetBodies();
                }
                // Step the world
                world.step(e.data.dt);

                // Copy over the data to the buffers
                var positions = e.data.positions;
                var quaternions = e.data.quaternions;
                for(var i=0; i < world.bodies.length; i++){
                    var b = world.bodies[i],
                        p = b.position,
                        q = b.quaternion;
                    positions[3*i + 0] = p.x;
                    positions[3*i + 1] = p.y;
                    positions[3*i + 2] = p.z;
                    quaternions[4*i + 0] = q.x;
                    quaternions[4*i + 1] = q.y;
                    quaternions[4*i + 2] = q.z;
                    quaternions[4*i + 3] = q.w;
                }

                // Send data back to the main thread
                self.postMessage({
                    positions:positions,
                    quaternions:quaternions
                }, [positions.buffer,
                    quaternions.buffer]);
            };
        </script>

        <script type="module">
            import * as THREE from 'https://unpkg.com/three@0.123.0/build/three.module.js';

            import Stats from 'https://unpkg.com/three@0.123.0/examples/jsm/libs/stats.module.js';

            import { OrbitControls } from 'https://unpkg.com/three@0.123.0/examples/jsm/controls/OrbitControls.js';
            import { FBXLoader } from 'https://unpkg.com/three@0.123.0/examples/jsm/loaders/FBXLoader.js';
            import { HDRCubeTextureLoader } from 'https://unpkg.com/three@0.123.0/examples/jsm/loaders/HDRCubeTextureLoader.js';

            // setup 
            const floorHeight = -0.2;
            var meshes = [];
            var container, stats, controls;
            var camera, cameraVR, scene, sceneVR, renderer, light;


            // for animation
            var clock = new THREE.Clock();
            var mixer, actions, actionWeights, currentAction;
            var idleAction, pickUpLeftAction, pickUpRightAction, hammerAction;
            var manager = new THREE.LoadingManager();
            var doneLoading = false;
            var handMesh = [];
            var handIndices = [];
            var handBones = [];
            var hammerMesh;
            var hammerObject;
            var hammerIndex;
            var handObject;
            var meshInitialPose = [];

            // for grasping
            let isPinched = false,
                isGrasped = false,
                pinchPos = new THREE.Vector3(0,0,0),
                desiredPose = new THREE.Matrix4(),
                hammerCanCollide = false;
            const N = 0;
            const maxFPS = 240;

            // for debugging
            let reset = false,
                showDebug = false,
                debugObj = [],
                displayObj = [],
                playAnim = true;

            // for VR
            let isUserInteracting = true,
                lon = 0, lat = 0,
                phi = 0, theta = 0,
                onPointerDownPointerX = 0,
                onPointerDownPointerY = 0,
                onPointerDownLon = 0,
                onPointerDownLat = 0,
                isVR = false;
            const distance = 50

            let showContent = false;

            init();
            animate();

            document.addEventListener("visibilitychange", event => {
              if (document.visibilityState == "visible") {
                playAnim = true
              } else {
                playAnim = false
              }
            })

            function init() {
                document.getElementById("reset").onclick = function() {
                    if (showContent) { document.getElementById("text").onclick() }
                    if (isVR) { document.getElementById("vr").onclick() }
                    if (!playAnim) { document.getElementById("playpause").onclick() }
                    reset = true;
                    isPinched = false;
                    isGrasped = false;
                    pinchPos.set(0,0,0);
                    hammerCanCollide = false;
                    playAnim=true;
                    switchAction(idleAction, 0.5);
                };
                document.getElementById("playpause").onclick = function() {
                    if (showContent) { document.getElementById("text").onclick() }
                    if (isVR) { document.getElementById("vr").onclick() }
                    playAnim = !playAnim;
                    if(playAnim) {
                        unPauseAllActions();
                    } else {
                        pauseAllActions();
                    }
                };
                document.getElementById("wireframes").onclick = function() {
                    if (showContent) { document.getElementById("text").onclick() }
                    if (isVR) { document.getElementById("vr").onclick() }
                    showDebug = !showDebug;
                    for(var i=0; i<displayObj.length; i++) {
                        displayObj[i].material.visible = !showDebug;
                    }
                    for(var i=0; i<debugObj.length; i++) {
                        debugObj[i].material.visible = showDebug;
                        console.log(debugObj[i].name)
                    }
                    document.getElementById('blackout').style.display = (showDebug ?  "block":"none")
                };
                document.getElementById("vr").onclick = function() {
                    if (showContent) { document.getElementById("text").onclick() }
                    isUserInteracting = true;
                    lon = 0; lat = 0;
                    phi = 0; theta = 0;
                    onPointerDownPointerX = window.innerWidth/2;
                    onPointerDownPointerY = window.innerHeight/2;
                    onPointerDownLon = 0;
                    onPointerDownLat = 0;
                    isVR = !isVR;
                    playAnim = !isVR;
                    if(isVR) {
                        document.addEventListener( 'pointermove', onPointerMove, false );
                    } else {
                        document.removeEventListener( 'pointermove', onPointerMove );
                    }
                };
                document.getElementById("text").onclick = function() {
                    if (isVR) { document.getElementById("vr").onclick() }
                    showContent = !showContent;
                    playAnim = !showContent;
                    document.getElementById('content').style.display = (showContent ?  "block":"none")
                }

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
                camera.position.set( 0, .7, 0.2 + floorHeight );
                camera.up.set(0,0,1)
                camera.near = 0.001;
                camera.far = 5;
                camera.lookAt(0,0,floorHeight - .5);
                camera.updateProjectionMatrix();

                scene = new THREE.Scene();
                window.scene = scene;
                window.THREE = THREE;

                light = new THREE.DirectionalLight( 0xffffff );
                light.position.set( 0, 0, 1.5);
                light.castShadow = true;
                light.shadow.camera.top = 1.5;
                light.shadow.camera.bottom = -1.5;
                light.shadow.camera.left = -1;
                light.shadow.camera.right = 1;
                light.shadow.camera.far = 5;
                light.shadow.camera
                scene.add( light );

                // scene.add( new THREE.CameraHelper( light.shadow.camera ) );

                //ground
                var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
                mesh.material = new THREE.ShadowMaterial();
                mesh.material.opacity = 0.2;
                mesh.receiveShadow = true;
                scene.add( mesh );
                meshInitialPose.push(new THREE.Matrix4());
                meshes.push(mesh);
                displayObj.push(mesh);

                // cubes
                var cubeGeo = new THREE.BoxGeometry( .1, .1, .1);
                var cubeMaterial = new THREE.MeshStandardMaterial( { color: 0x888888 } );
                for(var i=0; i<N; i++){
                    var cubeMesh = new THREE.Mesh( cubeGeo, cubeMaterial );
                    cubeMesh.castShadow = true;
                    meshes.push(cubeMesh);
                    meshInitialPose.push(new THREE.Matrix4());
                    scene.add( cubeMesh );
                }

                var grid = new THREE.GridHelper( 20, 200);
                grid.rotation.set(Math.PI/2,0,0);
                grid.position.set(0,0,floorHeight)
                grid.material.opacity = 0.2;
                grid.material.transparent = true;
                grid.material.visible=false;
                debugObj.push(grid);
                scene.add( grid );

                // model
                manager.onLoad = function ( ) {
                    console.log( 'Loading complete!');
                    // Start the worker!
                    positions = new Float32Array(meshes.length*3)
                    quaternions = new Float32Array(meshes.length*4)
                    bonePositions = new Float32Array(handIndices.length*3)
                    boneQuaternions = new Float32Array(handIndices.length*4)
                    sendDataToWorker();
                    doneLoading = true;
                };
                var loader = new FBXLoader(manager);
                var texLoader = new THREE.TextureLoader(manager);

                new HDRCubeTextureLoader()
                    .setDataType( THREE.UnsignedByteType )
                    .setPath( 'textures/pisaHDR/' )
                    .load( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ],
                        function ( hdrCubeMap ) {

                            var hdrCubeRenderTarget = pmremGenerator.fromCubemap( hdrCubeMap );
                            hdrCubeMap.dispose();
                            pmremGenerator.dispose();
                            // scene.background = hdrCubeRenderTarget.texture;
                            scene.environment = hdrCubeRenderTarget.texture;
                } );

                loader.load( 'models/hand.fbx', function ( object ) {

                    mixer = new THREE.AnimationMixer( object );

                    for (var i = 0; i < object.animations.length; i++) {
                        var name = object.animations[i].name
                        console.log(name)
                        if(name == "Armature|FingerWag") {//.includes("Armature|FingerWag")) {
                            idleAction = mixer.clipAction(object.animations[i]);
                        }
                        if(name == "Armature|LiftFloorLeft") {//.includes("LiftFloorLeft")) {
                            pickUpLeftAction = mixer.clipAction(object.animations[i]);
                        }
                        if(name == "Armature|LiftFloorRight") {//.includes("LiftFloorRight")) {
                            pickUpRightAction = mixer.clipAction(object.animations[i]);
                        }
                        if(name == "Armature|Hammer") {//.includes("LiftFloorRight")) {
                            hammerAction = mixer.clipAction(object.animations[i]);
                        }
                    }

                    actions = [idleAction, pickUpLeftAction, pickUpRightAction, hammerAction];
                    console.log(actions)
                    actionWeights = [1.0, 0.0, 0.0, 0.0];
                    currentAction = idleAction;

                    activateAllActions();

                    object.traverse( function ( child ) {

                        if ( child.isMesh ) {
                            if(child.name == "HandLines") {
                                child.castShadow = false;
                                child.receiveShadow = true;
                                child.material= new THREE.MeshBasicMaterial( {
                                    skinning: true,
                                    color: 0x000000
                                });
                                displayObj.push(child);

                            } else if(child.name == "HandMesh" || child.name == "Hand") {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material = new THREE.MeshStandardMaterial( {
                                    color: 0xffffff,
                                    skinning: true,
                                    map: texLoader.load('textures/HandLines.png'),
                                });
                                displayObj.push(child);
                            } else if(child.name.slice(0, 4) == "COL_") {
                                child.material= new THREE.MeshBasicMaterial( {
                                    color: 0x250505,
                                    wireframe: true
                                });
                                handBones.push(child.parent);
                                // console.log(child);
                                child.parent = null;
                                var mat = child.matrix.clone();
                                // var mat = new THREE.Matrix4();
                                // mat.setPosition(0,0,0);
                                meshInitialPose.push(mat);
                                // console.log(child.quaternion);
                                handMesh.push([{vertices: child.geometry.attributes.position,
                                                normals: child.geometry.attributes.normal,
                                                name: child.name}]);
                                handIndices.push(meshes.length);
                                debugObj.push(child);
                                child.matrixAutoUpdate  = false;
                                // console.log(handIndices)
                                meshes.push(child);
                                child.material.visible = showDebug;
                            }
                            
                        }

                    } );

                    // console.log(object)

                    scene.add( object );
                    handObject = object;

                    var sphere = new THREE.Mesh(new THREE.SphereGeometry(0.05,6,4),
                                                new THREE.MeshBasicMaterial({color: 0x050505,
                                                                             wireframe: true}));
                    scene.add( sphere );
                    handObject.parent = sphere;
                    sphere.material.visible = showDebug;
                    meshes.push(sphere);

                } );

                loader.load( 'models/hammer.fbx', function ( object ) {

                    hammerMesh = []

                    object.traverse( function ( child ) {
                        if ( child.isMesh && child.name.slice(0, 4) == "COL_") {
                            child.material= new THREE.MeshBasicMaterial( {
                                color: 0x101010,
                                wireframe: true
                            });
                            hammerMesh.push({vertices: child.geometry.attributes.position,
                                             normals: child.geometry.attributes.normal});
                            debugObj.push(child);
                            child.material.visible = showDebug;
                        }
                        else if ( child.isMesh ) {
                            var diffuse = texLoader.load( "textures/HammerDiffuse_1024.png" );
                            diffuse.encoding = THREE.sRGBEncoding;
                            var normalMap = texLoader.load( "textures/HammerNormals_final.png" );
                            var roughness = texLoader.load('textures/HammerRoughness_1024.png');
                            roughness.encoding = THREE.sRGBEncoding;

                            child.castShadow = true;
                            child.receiveShadow = true;
                            var material = new THREE.MeshStandardMaterial( {
                                metalnessMap: texLoader.load('textures/HammerMetalness_1024.png'),
                                roughnessMap: roughness,
                                color: 0xffffff, 
                                map: diffuse,
                                normalMap: normalMap,
                                shading: THREE.SmoothShading,
                                normalScale: new THREE.Vector2( 0.25, 0.25 )
                            } );
                            child.material = material;
                            displayObj.push(child);
                        }

                    } );

                    scene.add( object );
                    hammerObject = object;
                    meshInitialPose.push(object.matrix.clone());
                    meshes.push(object)

                } );

                // VR scene
                cameraVR = new THREE.PerspectiveCamera( 75, window.innerWidth / window.innerHeight, 1, 1100 );
                sceneVR = new THREE.Scene();
                const geometry = new THREE.SphereBufferGeometry( 500, 60, 40 );
                // invert the geometry on the x-axis so that all of the faces point inward
                geometry.scale( - 1, 1, 1 );
                const video = document.getElementById( 'video' );
                video.play();

                const texture = new THREE.VideoTexture( video );
                const material = new THREE.MeshBasicMaterial( { map: texture } );

                const meshVR = new THREE.Mesh( geometry, material );
                sceneVR.add( meshVR );


                renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                // Color space vars are updated in animate function
                renderer.shadowMap.enabled = true;
                container.appendChild( renderer.domElement );

                controls = new OrbitControls( camera, renderer.domElement );
                controls.target.set( 0, 0, 0 );
                controls.update();

                window.addEventListener( 'resize', onWindowResize, false );

                // stats
                // stats = new Stats();
                // container.appendChild( stats.dom ); 

                var pmremGenerator = new THREE.PMREMGenerator( renderer );
                pmremGenerator.compileEquirectangularShader();

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();


                cameraVR.aspect = window.innerWidth / window.innerHeight;
                cameraVR.updateProjectionMatrix();
                
                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function deactivateAllActions() {

                actions.forEach( function ( action ) {

                    action.stop();

                } );

            }

            function pauseAllActions() {

                actions.forEach( function ( action ) {

                    action.paused = true;

                } );

            }

            function unPauseAllActions() {

                actions.forEach( function ( action ) {

                    action.paused = false;

                } );

            }

            function switchAction(endAction, duration) {
                if(currentAction == endAction) {
                    return;
                }
                console.log("switching", currentAction, endAction);
                unPauseAllActions();
                setWeight( endAction, 1 );
                endAction.time = 0;
                currentAction.crossFadeTo( endAction, duration, false );
                currentAction = endAction;
            }

            // This function is needed, since animationAction.crossFadeTo() disables its start action and sets
            // the start action's timeScale to ((start animation's duration) / (end animation's duration))
            function setWeight( action, weight ) {
                action.enabled = true;
                action.setEffectiveTimeScale( 1 );
                action.setEffectiveWeight( weight );
            }

            function activateAllActions() {
                for (var i = 0; i <  actions.length; i++) {
                    setWeight( actions[i], actionWeights[i]);
                    actions[i].play();
                }

            }

            function setDesiredPose(pose, dt) {
                var position = new THREE.Vector3();
                var rotation = new THREE.Quaternion();
                desiredPose.decompose(position, rotation, new THREE.Vector3());
                var newPosition = new THREE.Vector3();
                var newRotation = new THREE.Quaternion();
                pose.decompose(newPosition, newRotation, new THREE.Vector3());
                // To make up for difference in frame rates
                var scalingFactor = Math.max(Math.min(10, dt / (1/60)), 0.5);
                position.lerp(newPosition, 0.1 * scalingFactor);
                rotation.slerp(newRotation, 0.05 * scalingFactor);
                desiredPose.compose(position, rotation, new THREE.Vector3(1,1,1));
            }

            function matchHandWithHammer(dt) {
                var mat = (new THREE.Matrix4()).copy(hammerObject.matrixWorld);
                var pos = new THREE.Vector3();
                var quat = new THREE.Quaternion();
                mat.decompose(pos, quat, new THREE.Vector3())
                var eul = (new THREE.Euler()).setFromQuaternion(quat);
                var x_vec = new THREE.Vector3();
                var y_vec = new THREE.Vector3();
                var z_vec = new THREE.Vector3();
                mat.extractBasis(x_vec, y_vec, z_vec);
                var offset = (new THREE.Vector3()).copy(z_vec);
                offset.multiplyScalar(-0.15)

                var direction = "none"

                // Move to hammer if it's tilted
                if(currentAction != hammerAction) {
                    var newRot = new THREE.Matrix4();
                    var new_z = new THREE.Vector3(0,0,1);
                    var new_x = (new THREE.Vector3()).crossVectors(new_z, z_vec).normalize ();
                    var new_y = (new THREE.Vector3()).crossVectors(new_z, new_x);
                    newRot.set(new_x.x, new_y.x, new_z.x, 0,
                               new_x.y, new_y.y, new_z.y, 0,
                               new_x.z, new_y.z, new_z.z, 0,
                               0      , 0      , 0      , 1)
                     if(Math.abs(z_vec.dot(new THREE.Vector3(0,0,1))) < 0.2 && pos.z < 0.1) {
                        direction = (x_vec.z > 0 ? "right" : "left")
                     }
                }

                if(currentAction == idleAction) {
                    hammerCanCollide = true;
                    if (direction == "left") {
                        switchAction(pickUpLeftAction, 0.5)
                    }
                    if (direction == "right") {
                        switchAction(pickUpRightAction, 0.5)
                    }
                    var handPose = (new THREE.Matrix4()).copy(handObject.matrixWorld);
                    setDesiredPose(handPose, dt);
                } else if(currentAction == pickUpLeftAction || currentAction == pickUpRightAction) {
                    hammerCanCollide = false;
                    // Check pinch and grasp state for constraints
                    if(currentAction.time > 20/24 && currentAction.time < 35/24){
                        isPinched = true;
                    } else {
                        isPinched = false;
                    }
                    if(currentAction.time > 35/24) {
                        isGrasped = true;
                    }

                    if(currentAction.time > currentAction.getClip().duration - 20/24) {
                        switchAction(hammerAction, 1)
                    }
                    // go to idle if we fail to pinch or grasp before hammer moves
                    if (direction == "none" && !isPinched && !isGrasped) {
                        switchAction(idleAction, 0.5);
                    }
                    // Move to target
                    pos.setZ(floorHeight);
                    pos.add(offset);
                    var handPose = (new THREE.Matrix4()).copy(newRot);
                    // console.log(newRot)
                    handPose.setPosition(pos);
                    setDesiredPose(handPose, dt);

                } else if(currentAction == hammerAction) {
                    hammerCanCollide = false;
                    var ca = Math.cos((new Date()).getTime()  / 1000 / 17)
                    var cb = Math.cos((new Date()).getTime()  / 1000 / 11)
                    var frequency = 10 + (cb + ca) / 2 * 1
                    // console.log(frequency)
                    frequency = 15;
                    var sinVal = Math.sin((new Date()).getTime() / 1000 * frequency)
                    var newPose = new THREE.Matrix4();
                    newPose.makeRotationX(-sinVal * 2);
                    newPose.premultiply((new THREE.Matrix4()).makeRotationZ(-Math.PI/2));
                    var zRot = Math.sin((new Date()).getTime() / 1000) + 1;
                    newPose.premultiply((new THREE.Matrix4()).makeRotationZ(zRot * Math.PI / 4 - 2));
                    newPose.setPosition(0, 0, (1+sinVal) / 2 * 0.3 - 0.2);
                    setDesiredPose(newPose, dt);
                }
            }

            function onPointerMove( event ) {

                if ( isUserInteracting === true ) {

                    lon = ( onPointerDownPointerX - event.clientX ) * - 0.1 + onPointerDownLon;
                    lat = ( onPointerDownPointerY - event.clientY ) * - 0.1 + onPointerDownLat;

                }

            }


            //
            function animate() {
                requestAnimationFrame( animate );

                var delta = clock.getDelta();

                // Update animations
                if ( mixer ) mixer.update( delta );

                // Handle mouse interaction in VR mode
                if(isVR) {
                    lat = Math.max( - 85, Math.min( 85, lat ) );
                    phi = THREE.MathUtils.degToRad( 90 - lat );
                    theta = THREE.MathUtils.degToRad( lon );
                    cameraVR.position.x = distance * Math.sin( phi ) * Math.cos( theta );
                    cameraVR.position.y = distance * Math.cos( phi );
                    cameraVR.position.z = distance * Math.sin( phi ) * Math.sin( theta );
                    cameraVR.lookAt( 0, 0, 0 );
                    renderer.toneMapping = THREE.NoToneMapping;
                    renderer.toneMappingExposure = 0.75;
                    renderer.outputEncoding = THREE.LinearEncoding;
                    renderer.render( sceneVR, cameraVR );
                } else { // Make sure colors are right for EXR lighting
                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = 1.25;
                    renderer.outputEncoding = THREE.sRGBEncoding;
                    renderer.render( scene, camera );
                }

                if(!doneLoading){
                    return;
                }

                // Update hand state
                matchHandWithHammer(delta);

                // stats.update();
                document.getElementById("fps").innerHTML = `fps: ${Math.round(1/dt)}`;
            }

            // Parameters
            var dt = 1/240;

            // Data arrays. Contains all our kinematic data we need for rendering.
            var positions;
            var quaternions;
            var bonePositions;
            var boneQuaternions;

            // Create a blob for the inline worker code
            var blob = new Blob([document.querySelector('#worker1').textContent],{type:'text/javascript'});

            // Create worker
            var worker = new Worker(window.URL.createObjectURL(blob));
            worker.postMessage = worker.webkitPostMessage || worker.postMessage;

            var sendTime; // Time when we sent last message
            worker.onmessage = function(e) {

                // Get fresh data from the worker
                positions = e.data.positions;
                quaternions = e.data.quaternions;

                // Update rendering meshes
                for(var i=0; i < meshes.length; i++){
                    meshes[i].position.set( positions[3*i+0],
                                            positions[3*i+1],
                                            positions[3*i+2] );
                    meshes[i].quaternion.set(quaternions[4*i+0],
                                             quaternions[4*i+1],
                                             quaternions[4*i+2],
                                             quaternions[4*i+3]);
                    meshes[i].updateMatrix();
                }

                // If the worker was faster than the time step (dt seconds), we want to delay the next timestep
                var delay =  1000 / maxFPS - (Date.now()-sendTime);
                if(delay < 0){
                    delay = 0;
                }
                setTimeout(sendDataToWorker,delay);
            }
            var firstDataSent = true;
            function sendDataToWorker(){
                if ( mixer ){
                    for(var i=0; i < handBones.length; i++) {
                        var position = new THREE.Vector3();
                        var quaternion = new THREE.Quaternion();
                        var scale = new THREE.Vector3();
                        // var mat = new THREE.Matrix4();
                        // mat.makeRotationX(-3.14/2);
                        // var mat = meshInitialPose[handIndices[i]]
                        // mat.premultiply(handBones[i].matrixWorld)
                        var mat = handBones[i].matrixWorld.clone();
                        // mat.setPosition(0,0,0)
                        mat.multiply(meshInitialPose[handIndices[i]])
                        mat.decompose( position, quaternion, scale );
                        bonePositions[i * 3 + 0] = position.x;
                        bonePositions[i * 3 + 1] = position.y;
                        bonePositions[i * 3 + 2] = position.z;

                        boneQuaternions[i * 4 + 0] = quaternion.x;
                        boneQuaternions[i * 4 + 1] = quaternion.y;
                        boneQuaternions[i * 4 + 2] = quaternion.z;
                        boneQuaternions[i * 4 + 3] = quaternion.w;
                    }
                }

                // update dt
                if (typeof sendTime !== 'undefined') {
                    var newdt = (Date.now()-sendTime) / 1000.0;
                    var nAverage = 60;
                    dt = Math.max(1/maxFPS, (dt * (nAverage - 1) + newdt) / nAverage);
                }

                sendTime = Date.now();
                var handPos = new THREE.Vector3();
                var handRot = new THREE.Quaternion();
                desiredPose.decompose(handPos, handRot, new THREE.Vector3());
                worker.postMessage({
                    reset : reset,
                    N : N,
                    dt : dt,
                    cannonUrl : document.location.href.replace(/\/[^/]*$/,"/") + "./js/cannon.js",
                    positions : positions,
                    quaternions : quaternions,
                    hammerMesh : (firstDataSent ? hammerMesh : null),
                    handMesh :   (firstDataSent ? handMesh : null),
                    bonePositions: bonePositions,
                    boneQuaternions: boneQuaternions,
                    handIndices: handIndices,
                    hammerIndex: hammerIndex,
                    isPinched: isPinched,
                    isGrasped: isGrasped,
                    hammerCanCollide: hammerCanCollide,
                    floorHeight:floorHeight,
                    handPos:handPos.toArray(),
                    handRot:handRot.toArray(),
                    playAnim: playAnim,

                },[positions.buffer, quaternions.buffer]);
                firstDataSent = false;

                reset = false;
            }
        </script>
    </body>
</html>
