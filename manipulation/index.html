<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - FBX loader</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
        <style type="text/css">
            body {
                background: radial-gradient(#cda381, #8b6a4e);
                margin:0;
            }
            #blackout {
                position:fixed;
                left:0;
                right:0;
                width:100vw;
                height:100vh;
                background-color: black;
                z-index:-100;
                display:none;
            }
            #controls {
                position:fixed;
                top:0;
                right:0;
                font-size:50px;
            }
            #controls > div {
                margin:10px;
            }
            #fps{
                font-size:12pt;
            }
            #reset::after {
                content:"\01F501";
            } #playpause::after {
                content:"\023EF";
            } #wireframes::after {
                content:"\01F310"; 
            }
        </style>
    </head>

    <body>
        <div id="blackout">
        </div>
        <div id="controls">
            <div id="fps">fps: 0</div>
            <div id="reset"></div>
            <div id="playpause"></div>
            <div id="wireframes"></div>
        </div>
        <!-- Worker script, will be run in separate thread -->
        <script id="worker1" type="module">
            var world;
            var hammerBody;
            var groundBody;
            var handBody;
            var hammerPivot;
            var hand = [];
            var lastPositions;
            var n_cubes;
            var indexConstraint, thumbConstraint, handConstraint;
            var isGrasped = false;

            function bodyFromMesh(mesh, options) {
                options = options || {};
                body = new CANNON.Body(options);
                for(var i=0; i<mesh.length; i++) {
                    var verts=[], faces=[], norms=[];
                    // Get vertices
                    var vertices = mesh[i].vertices.array.values();
                    var normals = mesh[i].normals.array.values();
                    var count = 0;
                    var face = [0,0,0];
                    for (var j=0; j<mesh[i].vertices.count; j+=1) {
                        if (count % 3 == 0 && count !=0){
                            var idx = verts.length-1;
                            var testNorm = verts[idx-1].vsub(verts[idx-2]).cross(verts[idx].vsub(verts[idx-2]));
                            var n = norms[idx-2].dot(testNorm)
                            if(false){//n < 0){
                                faces.push(face[0], face[2], face[1])
                            }
                            else {
                                faces.push(face);
                            }
                        }
                        verts.push(new CANNON.Vec3(vertices.next().value,
                                                   vertices.next().value,
                                                   vertices.next().value));
                        norms.push(new CANNON.Vec3(normals.next().value,
                                                   normals.next().value,
                                                   normals.next().value));
                        face[count%3] = j%3;
                        count ++;
                    }
                    var bodyPart = new CANNON.ConvexPolyhedron(verts,faces);
                    body.addShape(bodyPart)
                }
                return body;
            }

            function resetBodies() {
                // Everything but the floor and hand
                for(var i=1; i < n_cubes + 2; i++)
                {
                    // cubes
                    if(i < n_cubes+1)
                    {
                        world.bodies[i].position.set(Math.random()*.1-0.05,
                                                     Math.random()*.1-0.05,
                                                     0.25*(i+1)+0.05);
                    } else { // hammer
                        world.bodies[i].position.set(0.2,.1,0.1);
                        world.bodies[i].quaternion.set(0,-0.005,0,1);
                        hammerBody.quaternion.normalize();
                    }
                    world.bodies[i].velocity.set(0,0,0);
                    world.bodies[i].angularVelocity.set(0,0,0);
                }
            }

            self.onmessage = function(e) {
                if(!e.data.bonePositions || !e.data.playAnim) {
                    var positions = e.data.positions;
                    var quaternions = e.data.quaternions;
                    self.postMessage({
                        positions:positions,
                        quaternions:quaternions
                    }, [(positions ? positions.buffer : []),
                        (positions ? quaternions.buffer : [])]);
                    return;
                }
                if (e.data.cannonUrl && !world) {
                    // Load cannon.js
                    importScripts(e.data.cannonUrl);

                    // Init physics
                    world = new CANNON.World();
                    world.broadphase = new CANNON.NaiveBroadphase();
                    world.narrowphase
                    world.gravity.set(0,0,-9.8);
                    // world.solver = new CANNON.SplitSolver(world.solver);
                    // world.defaultContactMaterial.contactEquationStiffness = 1e10;
                    // world.defaultContactMaterial.contactEquationRelaxation = 10;
                    // world.defaultContactMaterial.restitution = 0.1;
                    world.quatNormalizeFast = true;

                    // Ground plane
                    var plane = new CANNON.Plane();
                    groundBody = new CANNON.Body({ mass: 0 });
                    groundBody.addShape(plane);
                    // groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
                    groundBody.position.set(0,0,e.data.floorHeight);
                    world.addBody(groundBody);

                    // Create N cubes
                    var shape = new CANNON.Box(new CANNON.Vec3(0.05,0.05,0.05));
                    for(var i=0; i!==e.data.N; i++){
                        var body = new CANNON.Body({ mass: .1 });
                        body.addShape(shape);
                        world.addBody(body);
                    }

                    // Create hammer
                    hammerBody = bodyFromMesh(e.data.hammerMesh, {mass:0.5})
                    world.addBody(hammerBody)

                    n_cubes = e.data.N;
                    resetBodies();

                    // Create hand
                    for(var i=0; i < e.data.handMesh.length; i++){
                        var pos = new CANNON.Vec3(e.data.bonePositions[i * 3 + 0],
                                                  e.data.bonePositions[i * 3 + 1],
                                                  e.data.bonePositions[i * 3 + 2]);
                        var quat = new CANNON.Quaternion(e.data.boneQuaternions[i * 4 + 0],
                                                         e.data.boneQuaternions[i * 4 + 1],
                                                         e.data.boneQuaternions[i * 4 + 2],
                                                         e.data.boneQuaternions[i * 4 + 3]);
                        var mesh = bodyFromMesh(e.data.handMesh[i], {mass: 0,
                                                                     angularDamping:0,
                                                                     linearDamping:0,
                                                                     type: CANNON.Body.KINEMATIC,
                                                                     position: pos,
                                                                     quaternion: quat,
                                                                     collisionFilterGroup:2})
                        var name = e.data.handMesh[i][0].name
                        console.log("name: ", name);

                        if (name == "COL_Hand") {
                            palmConstraint = new CANNON.LockConstraint(hammerBody, mesh);
                            // world.addConstraint(palmConstraint);
                        }
                        if (name == "COL_Hand001") {
                            var centerA = new CANNON.Vec3(0,0,-.15);
                            var centerB = new CANNON.Vec3(0,-0.02220,0.027414);
                            indexConstraint = new CANNON.PointToPointConstraint(hammerBody, centerA, mesh, centerB,0.1)
                            world.addConstraint(indexConstraint);
                        }
                        if (name == "COL_Hand010") {
                            var centerA = new CANNON.Vec3(0,0,-.15);
                            var centerB = new CANNON.Vec3(-0.018637,0.002901,0.028293);
                            thumbConstraint = new CANNON.PointToPointConstraint(hammerBody, centerA, mesh, centerB,0.1)
                            world.addConstraint(thumbConstraint);
                        }
                        if (name == "COL_HammerPivot") {
                            hammerPivot = mesh;
                            mesh.collisionFilterGroup = 4;
                            palmConstraint = new CANNON.LockConstraint(hammerBody, mesh,0.001);
                            palmConstraint.pivotA = new CANNON.Vec3(0,0,-.15 / 2);
                            world.addConstraint(palmConstraint);
                        }
                        // mesh.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
                        world.addBody(mesh);
                        // console.log(i,mesh)
                    };

                    // handBody = new CANNON.Body({ mass: 0.5,
                    //                              damping:0.6,
                    //                              collisionFilterGroup:8});
                    handBody = new CANNON.Body({ mass: 0,
                                                 type: CANNON.Body.KINEMATIC,
                                                 collisionFilterGroup:8});
                    handBody.addShape(new CANNON.Sphere(0.05));
                    world.addBody(handBody); 
                }

                if(e.data.reset) {
                    resetBodies();
                }

                if(e.data.hammerCanCollide && !e.data.isGrasped)
                    hammerBody.collisionFilterMask = 1|2;
                else
                    hammerBody.collisionFilterMask = 1;


                if(e.data.isPinched) {
                    indexConstraint.enable();
                    thumbConstraint.enable();
                } else {
                    indexConstraint.disable();
                    thumbConstraint.disable();
                }

                if(e.data.isGrasped) {
                    if(!isGrasped) {
                        world.removeConstraint(palmConstraint);
                        palmConstraint = new CANNON.LockConstraint(hammerBody, hammerPivot, 0.01);
                        palmConstraint.pivotA = new CANNON.Vec3(0,0,-.15/2);
                        world.addConstraint(palmConstraint);
                        palmConstraint.enable();
                    }
                    isGrasped = true;
                } else {
                    palmConstraint.disable();
                    isGrasped = false;
                }

                // Hand update
                for(var i=0; i<e.data.handIndices.length; i++){
                    // We don't need to update the hand. It's the first frame.
                    if(!lastPositions) {
                        continue;
                    }
                    var idx = e.data.handIndices[i]
                    // Rotation is set directly without angular velocity
                    var rot = [e.data.boneQuaternions[i * 4 + 0],
                               e.data.boneQuaternions[i * 4 + 1],
                               e.data.boneQuaternions[i * 4 + 2],
                               e.data.boneQuaternions[i * 4 + 3]];
                    world.bodies[idx].quaternion.set(rot[0], rot[1], rot[2], rot[3]);
                    // Position is applied via velocity
                    var vel = [(e.data.bonePositions[i * 3 + 0] - world.bodies[idx].position.x) / e.data.dt,
                               (e.data.bonePositions[i * 3 + 1] - world.bodies[idx].position.y) / e.data.dt,
                               (e.data.bonePositions[i * 3 + 2] - world.bodies[idx].position.z) / e.data.dt]
                    world.bodies[idx].velocity.set(vel[0], vel[1], vel[2]);

                    // world.bodies[idx].position.set(e.data.bonePositions[i * 3 + 0],
                    //                                e.data.bonePositions[i * 3 + 1],
                    //                                e.data.bonePositions[i * 3 + 2]);
                }

                var handPos = new CANNON.Vec3(e.data.handPos[0],
                                              e.data.handPos[1],
                                              e.data.handPos[2]);

                handBody.quaternion.set(e.data.handRot[0],
                                        e.data.handRot[1],
                                        e.data.handRot[2],
                                        e.data.handRot[3]);
                // e.data.desiredPose
                diff = handPos.vsub(handBody.position).scale(1 / e.data.dt);
                // console.log(diff);
                handBody.velocity.set(diff.x, diff.y, diff.z);
                // handBody.position.set(handPos.x, handPos.y, handPos.z)


                // diff.scale(2)
                // for(var i=0; i<e.data.handIndices.length; i++){
                //     var idx = e.data.handIndices[i];
                //     world.bodies[idx].velocity = world.bodies[idx].velocity.vadd(diff);
                // }
                if(isGrasped){
                    hammerBody.velocity.set(diff.x, diff.y, diff.z);
                }

                lastPositions = [...e.data.bonePositions];
                // Step the world
                world.step(e.data.dt);
                
                // world.collisionMatrixTick ()
                // console.log(world)

                // Copy over the data to the buffers
                var positions = e.data.positions;
                var quaternions = e.data.quaternions;
                for(var i=0; i < world.bodies.length; i++){
                    var b = world.bodies[i],
                        p = b.position,
                        q = b.quaternion;
                    positions[3*i + 0] = p.x;
                    positions[3*i + 1] = p.y;
                    positions[3*i + 2] = p.z;
                    quaternions[4*i + 0] = q.x;
                    quaternions[4*i + 1] = q.y;
                    quaternions[4*i + 2] = q.z;
                    quaternions[4*i + 3] = q.w;
                }

                // Send data back to the main thread
                self.postMessage({
                    positions:positions,
                    quaternions:quaternions
                }, [positions.buffer,
                    quaternions.buffer]);
            };
        </script>

        <script type="module">
            import * as THREE from 'https://unpkg.com/three@0.123.0/build/three.module.js';

            import Stats from 'https://unpkg.com/three@0.123.0/examples/jsm/libs/stats.module.js';

            import { OrbitControls } from 'https://unpkg.com/three@0.123.0/examples/jsm/controls/OrbitControls.js';
            import { FBXLoader } from 'https://unpkg.com/three@0.123.0/examples/jsm/loaders/FBXLoader.js';
            import { HDRCubeTextureLoader } from 'https://unpkg.com/three@0.123.0/examples/jsm/loaders/HDRCubeTextureLoader.js';

            var floorHeight = -0.2

            var meshes = [];
            var container, stats, controls;
            var camera, scene, renderer, light;

            var clock = new THREE.Clock();

            var mixer, actions, actionWeights, currentAction;
            var idleAction, pickUpLeftAction, pickUpRightAction, hammerAction;
            var manager = new THREE.LoadingManager();
            var doneLoading = false;
            var handMesh = [];
            var handIndices = [];
            var handBones = [];
            var hammerMesh;
            var hammerObject;
            var hammerIndex;
            var handObject;
            var meshInitialPose = [];

            var isPinched = false;
            var isGrasped = false;
            var pinchPos = new THREE.Vector3(0,0,0);
            var desiredPose = new THREE.Matrix4();
            var moveTime = 0;
            var handAccel = 0.1;
            var handVel = 0;
            var hammerCanCollide = false;
            var N = 0;
            var maxFPS = 240;

            // For debugging
            var reset = false;
            var showDebug = false;
            var debugObj = [];
            var displayObj = [];
            var playAnim = true;

            init();
            animate();

            function init() {
                document.getElementById("reset").onclick = function() {
                    reset = true;
                    isPinched = false;
                    isGrasped = false;
                    pinchPos.set(0,0,0);
                    hammerCanCollide = false;
                    playAnim=true;
                    switchAction(idleAction, 0.5);
                };
                document.getElementById("playpause").onclick = function() {
                    playAnim = !playAnim;
                    if(playAnim) {
                        unPauseAllActions();
                    } else {
                        pauseAllActions();
                    }
                };
                document.getElementById("wireframes").onclick = function() {
                    showDebug = !showDebug;
                    for(var i=0; i<displayObj.length; i++) {
                        displayObj[i].material.visible = !showDebug;
                    }
                    for(var i=0; i<debugObj.length; i++) {
                        debugObj[i].material.visible = showDebug;
                        console.log(debugObj[i].name)
                    }
                    document.getElementById('blackout').style.display = (showDebug ?  "block":"none")
                };

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
                camera.position.set( 0, .7, 0.2 + floorHeight );
                camera.up.set(0,0,1)
                camera.near = 0.001;
                camera.far = 5;
                camera.lookAt(0,0,floorHeight - .5);
                camera.updateProjectionMatrix();

                scene = new THREE.Scene();
                window.scene = scene;
                window.THREE = THREE;

                light = new THREE.DirectionalLight( 0xffffff );
                light.position.set( 0, 0, 1.5);
                light.castShadow = true;
                light.shadow.camera.top = 1.5;
                light.shadow.camera.bottom = -1.5;
                light.shadow.camera.left = -1;
                light.shadow.camera.right = 1;
                light.shadow.camera.far = 5;
                light.shadow.camera
                scene.add( light );

                // scene.add( new THREE.CameraHelper( light.shadow.camera ) );

                //ground
                var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
                mesh.material = new THREE.ShadowMaterial();
                mesh.material.opacity = 0.2;
                mesh.receiveShadow = true;
                scene.add( mesh );
                meshInitialPose.push(new THREE.Matrix4());
                meshes.push(mesh);
                displayObj.push(mesh);

                // cubes
                var cubeGeo = new THREE.BoxGeometry( .1, .1, .1);
                var cubeMaterial = new THREE.MeshStandardMaterial( { color: 0x888888 } );
                for(var i=0; i<N; i++){
                    var cubeMesh = new THREE.Mesh( cubeGeo, cubeMaterial );
                    cubeMesh.castShadow = true;
                    meshes.push(cubeMesh);
                    meshInitialPose.push(new THREE.Matrix4());
                    scene.add( cubeMesh );
                }

                var grid = new THREE.GridHelper( 20, 200);
                grid.rotation.set(Math.PI/2,0,0);
                grid.position.set(0,0,floorHeight)
                grid.material.opacity = 0.2;
                grid.material.transparent = true;
                grid.material.visible=false;
                debugObj.push(grid);
                scene.add( grid );

                // model
                manager.onLoad = function ( ) {
                    console.log( 'Loading complete!');
                    // Start the worker!
                    positions = new Float32Array(meshes.length*3)
                    quaternions = new Float32Array(meshes.length*4)
                    bonePositions = new Float32Array(handIndices.length*3)
                    boneQuaternions = new Float32Array(handIndices.length*4)
                    sendDataToWorker();
                    doneLoading = true;
                };
                var loader = new FBXLoader(manager);
                var texLoader = new THREE.TextureLoader(manager);

                new HDRCubeTextureLoader()
                    .setDataType( THREE.UnsignedByteType )
                    .setPath( 'textures/pisaHDR/' )
                    .load( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ],
                        function ( hdrCubeMap ) {

                            var hdrCubeRenderTarget = pmremGenerator.fromCubemap( hdrCubeMap );
                            hdrCubeMap.dispose();
                            pmremGenerator.dispose();
                            // scene.background = hdrCubeRenderTarget.texture;
                            scene.environment = hdrCubeRenderTarget.texture;
                } );

                loader.load( 'models/hand.fbx', function ( object ) {

                    mixer = new THREE.AnimationMixer( object );

                    for (var i = 0; i < object.animations.length; i++) {
                        var name = object.animations[i].name
                        console.log(name)
                        if(name == "Armature|FingerWag") {//.includes("Armature|FingerWag")) {
                            idleAction = mixer.clipAction(object.animations[i]);
                        }
                        if(name == "Armature|LiftFloorLeft") {//.includes("LiftFloorLeft")) {
                            pickUpLeftAction = mixer.clipAction(object.animations[i]);
                        }
                        if(name == "Armature|LiftFloorRight") {//.includes("LiftFloorRight")) {
                            pickUpRightAction = mixer.clipAction(object.animations[i]);
                        }
                        if(name == "Armature|Hammer") {//.includes("LiftFloorRight")) {
                            hammerAction = mixer.clipAction(object.animations[i]);
                        }
                    }

                    actions = [idleAction, pickUpLeftAction, pickUpRightAction, hammerAction];
                    console.log(actions)
                    actionWeights = [1.0, 0.0, 0.0, 0.0];
                    currentAction = idleAction;

                    activateAllActions();

                    object.traverse( function ( child ) {

                        if ( child.isMesh ) {
                            if(child.name == "HandLines") {
                                child.castShadow = false;
                                child.receiveShadow = true;
                                child.material= new THREE.MeshBasicMaterial( {
                                    skinning: true,
                                    color: 0x000000
                                });
                                displayObj.push(child);

                            } else if(child.name == "HandMesh" || child.name == "Hand") {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material = new THREE.MeshStandardMaterial( {
                                    color: 0xffffff,
                                    skinning: true,
                                    map: texLoader.load('textures/HandLines.png'),
                                });
                                displayObj.push(child);
                            } else if(child.name.slice(0, 4) == "COL_") {
                                child.material= new THREE.MeshBasicMaterial( {
                                    color: 0x250505,
                                    wireframe: true
                                });
                                handBones.push(child.parent);
                                // console.log(child);
                                child.parent = null;
                                var mat = child.matrix.clone();
                                // var mat = new THREE.Matrix4();
                                // mat.setPosition(0,0,0);
                                meshInitialPose.push(mat);
                                // console.log(child.quaternion);
                                handMesh.push([{vertices: child.geometry.attributes.position,
                                                normals: child.geometry.attributes.normal,
                                                name: child.name}]);
                                handIndices.push(meshes.length);
                                debugObj.push(child);
                                child.matrixAutoUpdate  = false;
                                // console.log(handIndices)
                                meshes.push(child);
                                child.material.visible = showDebug;
                            }
                            
                        }

                    } );

                    // console.log(object)

                    scene.add( object );
                    handObject = object;

                    var sphere = new THREE.Mesh(new THREE.SphereGeometry(0.05,6,4),
                                                new THREE.MeshBasicMaterial({color: 0x050505,
                                                                             wireframe: true}));
                    scene.add( sphere );
                    handObject.parent = sphere;
                    sphere.material.visible = showDebug;
                    meshes.push(sphere);

                } );

                loader.load( 'models/hammer.fbx', function ( object ) {

                    hammerMesh = []

                    object.traverse( function ( child ) {
                        if ( child.isMesh && child.name.slice(0, 4) == "COL_") {
                            child.material= new THREE.MeshBasicMaterial( {
                                color: 0x101010,
                                wireframe: true
                            });
                            hammerMesh.push({vertices: child.geometry.attributes.position,
                                             normals: child.geometry.attributes.normal});
                            debugObj.push(child);
                            child.material.visible = showDebug;
                        }
                        else if ( child.isMesh ) {
                            var diffuse = texLoader.load( "textures/HammerDiffuse_high_res.png" );
                            diffuse.encoding = THREE.sRGBEncoding;
                            var normalMap = texLoader.load( "textures/HammerNormals_final.png" );
                            var roughness = texLoader.load('textures/HammerRoughness.png');
                            roughness.encoding = THREE.sRGBEncoding;

                            child.castShadow = true;
                            child.receiveShadow = true;
                            var material = new THREE.MeshStandardMaterial( {
                                metalnessMap: texLoader.load('textures/HammerMetalness.png'),
                                roughnessMap: roughness,
                                color: 0xffffff, 
                                map: diffuse,
                                normalMap: normalMap,
                                shading: THREE.SmoothShading,
                                normalScale: new THREE.Vector2( 0.25, 0.25 )
                            } );
                            child.material = material;
                            displayObj.push(child);
                        }

                    } );

                    scene.add( object );
                    hammerObject = object;
                    meshInitialPose.push(object.matrix.clone());
                    meshes.push(object)

                } );

                renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.25;
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.shadowMap.enabled = true;
                container.appendChild( renderer.domElement );

                controls = new OrbitControls( camera, renderer.domElement );
                controls.target.set( 0, 0, 0 );
                controls.update();

                window.addEventListener( 'resize', onWindowResize, false );

                // stats
                stats = new Stats();
                container.appendChild( stats.dom ); 

                var pmremGenerator = new THREE.PMREMGenerator( renderer );
                pmremGenerator.compileEquirectangularShader();

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            function deactivateAllActions() {

                actions.forEach( function ( action ) {

                    action.stop();

                } );

            }

            function pauseAllActions() {

                actions.forEach( function ( action ) {

                    action.paused = true;

                } );

            }

            function unPauseAllActions() {

                actions.forEach( function ( action ) {

                    action.paused = false;

                } );

            }

            function switchAction(endAction, duration) {
                console.log("switching", currentAction, endAction);
                if(currentAction == endAction) {
                    console.log("Already playing action:", currentAction)
                    return;
                }
                unPauseAllActions();
                setWeight( endAction, 1 );
                console.log(actionWeights)
                endAction.time = 0;
                currentAction.crossFadeTo( endAction, duration, false );
                currentAction = endAction;
            }

            // This function is needed, since animationAction.crossFadeTo() disables its start action and sets
            // the start action's timeScale to ((start animation's duration) / (end animation's duration))

            function setWeight( action, weight ) {
                action.enabled = true;
                action.setEffectiveTimeScale( 1 );
                action.setEffectiveWeight( weight );
            }

            function activateAllActions() {
                for (var i = 0; i <  actions.length; i++) {
                    setWeight( actions[i], actionWeights[i]);
                    actions[i].play();
                }

            }

            function setDesiredPose(pose) {
                // moveTime = 0;
                var position = new THREE.Vector3();
                var rotation = new THREE.Quaternion();
                desiredPose.decompose(position, rotation, new THREE.Vector3());
                var newPosition = new THREE.Vector3();
                var newRotation = new THREE.Quaternion();
                pose.decompose(newPosition, newRotation, new THREE.Vector3());
                position.lerp(newPosition, 0.1);
                rotation.slerp(newRotation, 0.05);
                // rotation.setFromRotationMatrix(pose);
                // console.log(position, rotation, pose, desiredPose)
                desiredPose.compose(position, rotation, new THREE.Vector3(1,1,1));
                // desiredPose.copy(pose);
            }

            // function moveHand(dt) {
            //     var oldPos = new THREE.Vector3();
            //     var oldRot = new THREE.Quaternion();
            //     var desiredPos = new THREE.Vector3();
            //     var desiredRot = new THREE.Quaternion();
            //     handObject.matrix.decompose(oldPos, oldRot, new THREE.Vector3());
            //     desiredPose.decompose(desiredPos, desiredRot, new THREE.Vector3());
            //     moveTime += dt;
            //     var diff = (new THREE.Vector3()).subVectors(desiredPos, oldPos);
            //     var dist = diff.length();
            //     // handVel += (dist > 0 ? handAccel : -handAccel)
            //     // handVel = Math.min(2, Math.max(handVel, 0))
            //     // handVel = Math.min(2, (dist + handVel * 2) / 5.0);
            //     // handVel = Math.min(2, dist);
            //     handVel = 4;
            //     // console.log(handVel, dist, moveTime)
            //     if(handVel > 0 && dist > 0){
            //         var totTime = dist * handVel;
            //         moveTime = Math.min(moveTime, totTime);
            //         handObject.position.lerpVectors(oldPos, desiredPos, moveTime / totTime);
            //     }

            //     handObject.position.copy(desiredPos);
            // }

            function matchHandWithHammer(dt) {
                var mat = (new THREE.Matrix4()).copy(hammerObject.matrixWorld);
                var pos = new THREE.Vector3();
                var quat = new THREE.Quaternion();
                mat.decompose(pos, quat, new THREE.Vector3())
                var eul = (new THREE.Euler()).setFromQuaternion(quat);
                var x_vec = new THREE.Vector3();
                var y_vec = new THREE.Vector3();
                var z_vec = new THREE.Vector3();
                mat.extractBasis(x_vec, y_vec, z_vec);
                var offset = (new THREE.Vector3()).copy(z_vec);
                offset.multiplyScalar(-0.15)

                var direction = "none"

                // Move to hammer if it's tilted
                if(currentAction != hammerAction) {
                    var newRot = new THREE.Matrix4();
                    var new_z = new THREE.Vector3(0,0,1);
                    var new_x = (new THREE.Vector3()).crossVectors(new_z, z_vec).normalize ();
                    var new_y = (new THREE.Vector3()).crossVectors(new_z, new_x);
                    newRot.set(new_x.x, new_y.x, new_z.x, 0,
                               new_x.y, new_y.y, new_z.y, 0,
                               new_x.z, new_y.z, new_z.z, 0,
                               0      , 0      , 0      , 1)
                     if(Math.abs(z_vec.dot(new THREE.Vector3(0,0,1))) < 0.2) {
                        direction = (x_vec.z > 0 ? "right" : "left")
                     }
                }

                if(currentAction == idleAction) {
                    hammerCanCollide = true;
                    if (direction == "left") {
                        switchAction(pickUpLeftAction, 0.5)
                    }
                    if (direction == "right") {
                        switchAction(pickUpRightAction, 0.5)
                    }
                } else if(currentAction == pickUpLeftAction || currentAction == pickUpRightAction) {
                    hammerCanCollide = false;
                    // Check pinch and grasp state for constraints
                    if(currentAction.time > 20/24 && currentAction.time < 35/24){
                        isPinched = true;
                    } else {
                        isPinched = false;
                    }
                    if(currentAction.time > 35/24) {
                        isGrasped = true;
                    }

                    if(currentAction.time > currentAction.getClip().duration - 20/24) {
                        switchAction(hammerAction, 1)
                    }
                    // go to idle if we fail to pinch or grasp before hammer moves
                    if (direction == "none" && !isPinched && !isGrasped) {
                        switchAction(idleAction, 0.5);
                    }
                    // Move to target
                    pos.setZ(floorHeight);
                    pos.add(offset);
                    var handPose = (new THREE.Matrix4()).copy(newRot);
                    // console.log(newRot)
                    handPose.setPosition(pos);
                    setDesiredPose(handPose);

                } else if(currentAction == hammerAction) {
                    hammerCanCollide = false;
                    var ca = Math.cos((new Date()).getTime()  / 1000 / 17)
                    var cb = Math.cos((new Date()).getTime()  / 1000 / 11)
                    var frequency = 10 + (cb + ca) / 2 * 1
                    // console.log(frequency)
                    frequency = 15;
                    var sinVal = Math.sin((new Date()).getTime() / 1000 * frequency)
                    var newPose = new THREE.Matrix4();
                    newPose.makeRotationX(-sinVal * 2);
                    newPose.premultiply((new THREE.Matrix4()).makeRotationZ(-Math.PI/2));
                    var zRot = Math.sin((new Date()).getTime() / 1000) + 1;
                    newPose.premultiply((new THREE.Matrix4()).makeRotationZ(zRot * Math.PI / 4 - 2));
                    newPose.setPosition(0, 0, (1+sinVal) / 2 * 0.3 - 0.2);
                    setDesiredPose(newPose);
                }
                
                // // actionWeights=[1,0,0, 0];
                // isPinched = false;

                // var newRot = new THREE.Matrix4();
                // // newRot.set(x_vec.x, y_vec.x, z_vec.x, 0,
                // //            x_vec.y, y_vec.y, z_vec.y, 0,
                // //            x_vec.z, y_vec.z, z_vec.z, 0,
                // //            0      , 0      , 0      , 1)
                
                // // newRot.multiply((new THREE.Matrix4()).makeRotationX(-Math.PI/2))
                // // newRot.multiply((new THREE.Matrix4()).makeRotationY(Math.PI))

                // if(Math.abs(z_vec.dot(new THREE.Vector3(0,0,1))) < 0.2 || isPinched || isGrasped){
                //     var new_z = new THREE.Vector3(0,0,1);
                //     var new_x = (new THREE.Vector3()).crossVectors(new_z, z_vec).normalize ();
                //     var new_y = (new THREE.Vector3()).crossVectors(new_z, new_x);
                //     newRot.set(new_x.x, new_y.x, new_z.x, 0,
                //                new_x.y, new_y.y, new_z.y, 0,
                //                new_x.z, new_y.z, new_z.z, 0,
                //                0      , 0      , 0      , 1)
                //     hammerCanCollide = false;
                //     var direction = (x_vec.z > 0 ? "right" : "left")
                //     // var new_z = new THREE.Vector3(0,0,1);
                //     // var new_y = (new THREE.Vector3()).crossVectors(new_z, z_vec);
                //     // var new_x = (new THREE.Vector3()).crossVectors(new_z, new_y);
                //     // var newRot = new THREE.Matrix4();
                //     // newRot.set(new_x.x, new_y.x, new_z.x, 0,
                //     //            new_x.y, new_y.y, new_z.y, 0,
                //     //            new_x.z, new_y.z, new_z.z, 0,
                //     //            0      , 0      , 0      , 1)
                //     // handObject.rotation.setFromRotationMatrix (newRot);
                //     // console.log(handObject.rotation)
                //     // // console.log("horizontal", direction, eul)
                //     var isIdle = !isHammering && !isPinched && !isGrasped
                //     if (direction == "left" && isIdle) {
                //         if(pickUpLeftAction.time > 20/24 && pickUpLeftAction.time < 35/24){
                //             isPinched = true;
                //         } else {
                //             isPinched = false;
                //         }

                //         if(pickUpLeftAction.time > 35/24) {
                //             isGrasped = true;
                //         }

                //         if(pickUpRightAction.time > 70/24) {
                //             isHammering = true;
                //         }

                //         switchAction(pickUpLeftAction, 0.5)
                //     } else if(isIdle) {
                //         if(pickUpRightAction.time > 20/24 && pickUpRightAction.time < 35/24){
                //             isPinched = true;
                //         } else {
                //             isPinched = false;
                //         } 

                //         if(pickUpRightAction.time > 35/24) {
                //             isGrasped = true;
                //         }

                //         if(pickUpRightAction.time > 50/24) {
                //             isHammering = true;
                //         }
                //         switchAction(pickUpLeftAction, 0.5)
                //     }

                //     if(!isPinched) {
                //         pinchPos.set(0,0,0);
                //     }

                //     if(pinchPos.length() == 0 && !isGrasped) {
                //         // pickUpLeftAction.time = 0;
                //         // pickUpRightAction.time = 0;
                //         pinchPos.copy(pos);
                //         pinchPos.setZ(floorHeight);
                //         pinchPos.add(offset);
                //         // handObject.position.copy(pinchPos);
                //     }
                //     // // console.log(handObject.rotation)
                // } else if(!isHammering){
                //     pickUpLeftAction.time = 0;
                //     pickUpRightAction.time = 0;
                //     // hammerCanCollide = true;
                //     // actionWeights=[1,0,0];
                //     // isPinched = false;
                // }
                // if(!isGrasped) {
                //     var handPose = (new THREE.Matrix4()).copy(newRot);
                //     // console.log(newRot)
                //     handPose.setPosition(pinchPos);
                //     setDesiredPose(handPose);
                //     // handObject.rotation.setFromRotationMatrix (newRot);
                // } if(isHammering) {
                //     var newPose = new THREE.Matrix4();
                //     var sinVal = Math.sin((new Date()).getTime() / 1000 * 10)
                //     newPose.makeRotationX(sinVal);
                //     // newPose.premultiply((new THREE.Matrix4).makeRotationX(Math.PI/2));
                //     // newPose.set(1,0,0,0,
                //     //             0,0,-1,0,
                //     //             0,1,0,0,
                //     //             0,0,0,1)
                //     // newPose.makeRotationX(Math.PI/2);
                //     // newPose.multiply((new THREE.Matrix4).makeRotationZ(-sinVal + 0.5));
                //     // newPose.multiply((new THREE.Matrix4).makeRotationY(-Math.PI/2))
                //     newPose.setPosition(0, 0, (1+sinVal) / 2 * 0.3 - 0.1);
                //     setDesiredPose(newPose);
                //     console.log("Switch to hammer")
                //     switchAction(hammerAction, 1);
                // }
                // // activateAllActions()
            }

            //
            function animate() {
                requestAnimationFrame( animate );

                var delta = clock.getDelta();

                if ( mixer ) mixer.update( delta );
                renderer.render( scene, camera );

                stats.update();
                if(!doneLoading){
                    console.log(handObject);
                    console.log(hammerObject);
                    return;
                }
                // moveHand(dt);
                matchHandWithHammer(dt);
                document.getElementById("fps").innerHTML = `fps: ${Math.round(1/dt)}`;
            }

            // Parameters
            var dt = 1/240;

            // Data arrays. Contains all our kinematic data we need for rendering.
            var positions;
            var quaternions;
            var bonePositions;
            var boneQuaternions;

            // Create a blob for the inline worker code
            var blob = new Blob([document.querySelector('#worker1').textContent],{type:'text/javascript'});

            // Create worker
            var worker = new Worker(window.URL.createObjectURL(blob));
            worker.postMessage = worker.webkitPostMessage || worker.postMessage;

            var sendTime; // Time when we sent last message
            worker.onmessage = function(e) {

                // Get fresh data from the worker
                positions = e.data.positions;
                quaternions = e.data.quaternions;

                // console.log(e.data.positions)
                // console.log(meshes.length * 3, positions.length, e.data.positions.length, meshes);
                // Update rendering meshes
                for(var i=0; i < meshes.length; i++){
                    meshes[i].position.set( positions[3*i+0],
                                            positions[3*i+1],
                                            positions[3*i+2] );
                    meshes[i].quaternion.set(quaternions[4*i+0],
                                             quaternions[4*i+1],
                                             quaternions[4*i+2],
                                             quaternions[4*i+3]);
                    meshes[i].updateMatrix();
                }

                // If the worker was faster than the time step (dt seconds), we want to delay the next timestep
                var delay =  1000 / maxFPS - (Date.now()-sendTime);
                if(delay < 0){
                    delay = 0;
                }
                setTimeout(sendDataToWorker,delay);
            }
            var firstDataSent = true;
            function sendDataToWorker(){
                if ( mixer ){
                    for(var i=0; i < handBones.length; i++) {
                        var position = new THREE.Vector3();
                        var quaternion = new THREE.Quaternion();
                        var scale = new THREE.Vector3();
                        // var mat = new THREE.Matrix4();
                        // mat.makeRotationX(-3.14/2);
                        // var mat = meshInitialPose[handIndices[i]]
                        // mat.premultiply(handBones[i].matrixWorld)
                        var mat = handBones[i].matrixWorld.clone();
                        // mat.setPosition(0,0,0)
                        mat.multiply(meshInitialPose[handIndices[i]])
                        mat.decompose( position, quaternion, scale );
                        bonePositions[i * 3 + 0] = position.x;
                        bonePositions[i * 3 + 1] = position.y;
                        bonePositions[i * 3 + 2] = position.z;

                        boneQuaternions[i * 4 + 0] = quaternion.x;
                        boneQuaternions[i * 4 + 1] = quaternion.y;
                        boneQuaternions[i * 4 + 2] = quaternion.z;
                        boneQuaternions[i * 4 + 3] = quaternion.w;
                    }
                }

                // update dt
                if (typeof sendTime !== 'undefined') {
                    var newdt = (Date.now()-sendTime) / 1000.0;
                    var nAverage = 60;
                    dt = Math.max(1/maxFPS, (dt * (nAverage - 1) + newdt) / nAverage);
                }

                sendTime = Date.now();
                var handPos = new THREE.Vector3();
                var handRot = new THREE.Quaternion();
                desiredPose.decompose(handPos, handRot, new THREE.Vector3());
                worker.postMessage({
                    reset : reset,
                    N : N,
                    dt : dt,
                    cannonUrl : document.location.href.replace(/\/[^/]*$/,"/") + "./js/cannon.js",
                    positions : positions,
                    quaternions : quaternions,
                    hammerMesh : (firstDataSent ? hammerMesh : null),
                    handMesh :   (firstDataSent ? handMesh : null),
                    bonePositions: bonePositions,
                    boneQuaternions: boneQuaternions,
                    handIndices: handIndices,
                    hammerIndex: hammerIndex,
                    isPinched: isPinched,
                    isGrasped: isGrasped,
                    hammerCanCollide: hammerCanCollide,
                    floorHeight:floorHeight,
                    handPos:handPos.toArray(),
                    handRot:handRot.toArray(),
                    playAnim: playAnim,

                },[positions.buffer, quaternions.buffer]);
                firstDataSent = false;

                reset = false;
            }
        </script>
    </body>
</html>
