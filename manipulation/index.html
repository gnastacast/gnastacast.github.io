<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - FBX loader</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
        <style type="text/css">
            body {
                background: radial-gradient(#cda381, #8b6a4e);
                margin:0;
            }
            #controls {
                position:fixed;
                top:0;
                right:0;
                font-size:50px;
            }
            #controls > div {
                margin:10px;
            }
            #fps{
                font-size:12pt;
            }
            #reset::after {
                content:"\01F501";
            } #playpause::after {
                content:"\023EF";
            } #wireframes::after {
                content:"\01F310"; 
            }
        </style>
    </head>

    <body>
        <div id="controls">
            <div id="fps">fps: 0</div>
            <div id="reset"></div>
            <div id="playpause"></div>
            <div id="wireframes"></div>
        </div>
        <!-- Worker script, will be run in separate thread -->
        <script id="worker1" type="module">
            var world;
            var hammer;
            var hand = [];
            var lastPositions;
            var n_cubes;

            function bodyFromMesh(mesh, options) {
                options = options || {};
                body = new CANNON.Body(options);
                for(var i=0; i<mesh.length; i++) {
                    var verts=[], faces=[], norms=[];
                    // Get vertices
                    var vertices = mesh[i].vertices.array.values();
                    var normals = mesh[i].normals.array.values();
                    var count = 0;
                    var face = [0,0,0];
                    for (var j=0; j<mesh[i].vertices.count; j+=1) {
                        if (count % 3 == 0 && count !=0){
                            var idx = verts.length-1;
                            var testNorm = verts[idx-1].vsub(verts[idx-2]).cross(verts[idx].vsub(verts[idx-2]));
                            var n = norms[idx-2].dot(testNorm)
                            if(false){//n < 0){
                                faces.push(face[0], face[2], face[1])
                            }
                            else {
                                faces.push(face);
                            }
                        }
                        verts.push(new CANNON.Vec3(vertices.next().value,
                                                   vertices.next().value,
                                                   vertices.next().value));
                        norms.push(new CANNON.Vec3(normals.next().value,
                                                   normals.next().value,
                                                   normals.next().value));
                        face[count%3] = j%3;
                        count ++;
                    }
                    var bodyPart = new CANNON.ConvexPolyhedron(verts,faces);
                    body.addShape(bodyPart)
                }
                return body;
            }

            function resetBodies() {
                // Everything but the floor and hand
                for(var i=1; i < n_cubes + 2; i++)
                {
                    // cubes
                    if(i < n_cubes+1)
                    {
                        world.bodies[i].position.set(Math.random()*.1-0.05,
                                                     Math.random()*.1-0.05,
                                                     0.25*(i+1)+0.05);
                    } else { // hammer
                        world.bodies[i].position.set(0.1,.1,0.1);
                        world.bodies[i].quaternion.set(0,-0.005,0,1);
                        hammer.quaternion.normalize();
                    }
                    world.bodies[i].velocity.set(0,0,0);
                    world.bodies[i].angularVelocity.set(0,0,0);
                }
            }

            self.onmessage = function(e) {
                if(!e.data.bonePositions) {
                    var positions = e.data.positions;
                    var quaternions = e.data.quaternions;
                    self.postMessage({
                        positions:positions,
                        quaternions:quaternions
                    }, [(positions ? positions.buffer : []),
                        (positions ? quaternions.buffer : [])]);
                    return;
                }
                if (e.data.cannonUrl && !world) {
                    // Load cannon.js
                    importScripts(e.data.cannonUrl);

                    // Init physics
                    world = new CANNON.World();
                    world.broadphase = new CANNON.NaiveBroadphase();
                    world.narrowphase
                    world.gravity.set(0,0,-9.8);
                    world.solver.tolerance = 0.0001;
                    world.solver.iterations = 100;
                    world.defaultContactMaterial.contactEquationStiffness = 1e10;
                    world.defaultContactMaterial.contactEquationRelaxation = 10;
                    world.defaultContactMaterial.restitution = 0.1;
                    world.quatNormalizeFast = true;

                    // Ground plane
                    var plane = new CANNON.Plane();
                    var groundBody = new CANNON.Body({ mass: 0 });
                    groundBody.addShape(plane);
                    // groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
                    groundBody.position.set(0,0,-.2);
                    world.addBody(groundBody);

                    // Create N cubes
                    var shape = new CANNON.Box(new CANNON.Vec3(0.05,0.05,0.05));
                    for(var i=0; i!==e.data.N; i++){
                        var body = new CANNON.Body({ mass: .1 });
                        body.addShape(shape);
                        world.addBody(body);
                    }

                    // Create hammer
                    hammer = bodyFromMesh(e.data.hammerMesh, {mass:0.5})
                    world.addBody(hammer)

                    n_cubes = e.data.N;
                    resetBodies();

                    // Create hand
                    for(var i=0; i < e.data.handMesh.length; i++){
                        var pos = new CANNON.Vec3(e.data.bonePositions[i * 3 + 0],
                                                  e.data.bonePositions[i * 3 + 1],
                                                  e.data.bonePositions[i * 3 + 2]);
                        var quat = new CANNON.Quaternion(e.data.boneQuaternions[i * 4 + 0],
                                                         e.data.boneQuaternions[i * 4 + 1],
                                                         e.data.boneQuaternions[i * 4 + 2],
                                                         e.data.boneQuaternions[i * 4 + 3]);
                        var mesh = bodyFromMesh(e.data.handMesh[i], {mass: 0,
                                                                     angularDamping:0,
                                                                     linearDamping:0,
                                                                     type: CANNON.Body.KINEMATIC,
                                                                     position: pos,
                                                                     quaternion: quat})
                        // mesh.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
                        world.addBody(mesh);
                        // console.log(i,mesh)
                    };
                }

                if(e.data.reset) {
                    resetBodies();
                }

                // Hand update
                for(var i=0; i<e.data.handIndices.length; i++){
                    // We don't need to update the hand. It's the first frame.
                    if(!lastPositions) {
                        continue;
                    }
                    var idx = e.data.handIndices[i]
                    // Rotation is set directly without angular velocity
                    var rot = [e.data.boneQuaternions[i * 4 + 0],
                               e.data.boneQuaternions[i * 4 + 1],
                               e.data.boneQuaternions[i * 4 + 2],
                               e.data.boneQuaternions[i * 4 + 3]];
                    world.bodies[idx].quaternion.set(rot[0], rot[1], rot[2], rot[3]);
                    // Position is applied via velocity
                    var vel = [(e.data.bonePositions[i * 3 + 0] - world.bodies[idx].position.x) / e.data.dt,
                               (e.data.bonePositions[i * 3 + 1] - world.bodies[idx].position.y) / e.data.dt,
                               (e.data.bonePositions[i * 3 + 2] - world.bodies[idx].position.z) / e.data.dt]
                    world.bodies[idx].velocity.set(vel[0], vel[1], vel[2]);
                }

                lastPositions = [...e.data.bonePositions];
                // Step the world
                world.step(e.data.dt);
                // world.collisionMatrixTick ()
                // console.log(world)

                // Copy over the data to the buffers
                var positions = e.data.positions;
                var quaternions = e.data.quaternions;
                for(var i=0; i < world.bodies.length; i++){
                    var b = world.bodies[i],
                        p = b.position,
                        q = b.quaternion;
                    positions[3*i + 0] = p.x;
                    positions[3*i + 1] = p.y;
                    positions[3*i + 2] = p.z;
                    quaternions[4*i + 0] = q.x;
                    quaternions[4*i + 1] = q.y;
                    quaternions[4*i + 2] = q.z;
                    quaternions[4*i + 3] = q.w;
                }

                // Send data back to the main thread
                self.postMessage({
                    positions:positions,
                    quaternions:quaternions
                }, [positions.buffer,
                    quaternions.buffer]);
            };
        </script>

        <script type="module">
            import * as THREE from './jsm/THREE/three.module.js';

            import Stats from './jsm/THREE/libs/stats.module.js';

            import { OrbitControls } from './jsm/THREE/controls/OrbitControls.js';
            import { FBXLoader } from './jsm/THREE/loaders/FBXLoader.js';
            import { HDRCubeTextureLoader } from './jsm/THREE/loaders/HDRCubeTextureLoader.js';

            var meshes = [];
            var container, stats, controls;
            var camera, scene, renderer, light;

            var clock = new THREE.Clock();

            var mixer, action;
            var manager = new THREE.LoadingManager();
            var doneLoading = false;
            var handMesh = [];
            var handIndices = [];
            var handBones = [];
            var hammerMesh;
            var hammerObject;
            var hammerIndex;
            var meshInitialPose = [];

            var N = 5;
            var maxFPS = 240;

            // For debugging
            var reset = false;
            var showDebug = true;
            var debugObj = [];
            var playAnim = true;

            init();
            animate();

            function init() {
                document.getElementById("reset").onclick = function() { reset = true;};
                document.getElementById("playpause").onclick = function() {
                    playAnim = !playAnim;
                    action.paused = playAnim;
                };
                document.getElementById("wireframes").onclick = function() {
                    showDebug = !showDebug;
                    for(var i=0; i<debugObj.length; i++) {
                        debugObj[i].visible = showDebug;
                    }
                };

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
                camera.position.set( 0, .7, 0.2 );
                camera.up.set(0,0,1)
                camera.near = 0.001;
                camera.far = 5;
                camera.updateProjectionMatrix();

                scene = new THREE.Scene();
                window.scene = scene;
                window.THREE = THREE;

                light = new THREE.DirectionalLight( 0xffffff );
                light.position.set( 0, 0, 1.5);
                light.castShadow = true;
                light.shadow.camera.top = 1.5;
                light.shadow.camera.bottom = -1.5;
                light.shadow.camera.left = -1;
                light.shadow.camera.right = 1;
                light.shadow.camera.far = 5;
                light.shadow.camera
                scene.add( light );

                // scene.add( new THREE.CameraHelper( light.shadow.camera ) );

                //ground
                var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
                mesh.material = new THREE.ShadowMaterial();
                mesh.material.opacity = 0.2;
                mesh.receiveShadow = true;
                scene.add( mesh );
                mesh.position.y = -1;
                meshInitialPose.push(new THREE.Matrix4());
                meshes.push(mesh);

                // cubes
                var cubeGeo = new THREE.BoxGeometry( .1, .1, .1);
                var cubeMaterial = new THREE.MeshStandardMaterial( { color: 0x888888 } );
                for(var i=0; i<N; i++){
                    var cubeMesh = new THREE.Mesh( cubeGeo, cubeMaterial );
                    cubeMesh.castShadow = true;
                    meshes.push(cubeMesh);
                    meshInitialPose.push(new THREE.Matrix4());
                    scene.add( cubeMesh );
                }

                // var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
                // grid.material.opacity = 0.2;
                // grid.material.transparent = true;
                // scene.add( grid );

                // model
                manager.onLoad = function ( ) {
                    console.log( 'Loading complete!');
                    // Start the worker!
                    positions = new Float32Array(meshes.length*3)
                    quaternions = new Float32Array(meshes.length*4)
                    bonePositions = new Float32Array(handIndices.length*3)
                    boneQuaternions = new Float32Array(handIndices.length*4)
                    sendDataToWorker();
                    doneLoading = true;
                };
                var loader = new FBXLoader(manager);
                var texLoader = new THREE.TextureLoader(manager);

                new HDRCubeTextureLoader()
                    .setDataType( THREE.UnsignedByteType )
                    .setPath( 'textures/pisaHDR/' )
                    .load( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ],
                        function ( hdrCubeMap ) {

                            var hdrCubeRenderTarget = pmremGenerator.fromCubemap( hdrCubeMap );
                            hdrCubeMap.dispose();
                            pmremGenerator.dispose();
                            // scene.background = hdrCubeRenderTarget.texture;
                            scene.environment = hdrCubeRenderTarget.texture;
                } );

                loader.load( 'models/hand.fbx', function ( object ) {

                    mixer = new THREE.AnimationMixer( object );

                    action = mixer.clipAction( object.animations[ 0 ] );
                    action.play();

                    object.traverse( function ( child ) {

                        if ( child.isMesh ) {
                            if(child.name == "HandLines") {
                                child.castShadow = false;
                                child.receiveShadow = true;
                                child.material= new THREE.MeshBasicMaterial( {
                                    skinning: true,
                                    color: 0x000000
                                });

                            } else if(child.name == "Hand") {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material = new THREE.MeshStandardMaterial( {
                                    color: 0xffffff,
                                    skinning: true,
                                    map: texLoader.load('textures/HandLines.png'),
                                });
                            } else if(child.name.slice(0, 3) == "COL") {
                                handBones.push(child.parent);
                                // console.log(child);
                                child.parent = null;
                                var mat = child.matrix.clone();
                                // var mat = new THREE.Matrix4();
                                // mat.setPosition(0,0,0);
                                meshInitialPose.push(mat);
                                // console.log(child.quaternion);
                                child.material.wireframe = true;
                                handMesh.push([{vertices: child.geometry.attributes.position,
                                                normals: child.geometry.attributes.normal}]);
                                handIndices.push(meshes.length);
                                debugObj.push(child);
                                // console.log(handIndices)
                                meshes.push(child);
                            }
                            
                        }

                    } );

                    // console.log(object)

                    scene.add( object );

                } );

                loader.load( 'models/hammer.fbx', function ( object ) {

                    hammerMesh = []

                    object.traverse( function ( child ) {
                        if ( child.isMesh && child.name.slice(0, 3) == "COL") {
                            child.material.wireframe = true;
                            hammerMesh.push({vertices: child.geometry.attributes.position,
                                             normals: child.geometry.attributes.normal});
                            debugObj.push(child);
                        }
                        else if ( child.isMesh ) {
                            var diffuse = texLoader.load( "textures/HammerDiffuse_high_res.png" );
                            diffuse.encoding = THREE.sRGBEncoding;
                            var normalMap = texLoader.load( "textures/HammerNormals_final.png" );
                            var roughness = texLoader.load('textures/HammerRoughness.png');
                            roughness.encoding = THREE.sRGBEncoding;

                            child.castShadow = true;
                            child.receiveShadow = true;
                            var material = new THREE.MeshStandardMaterial( {
                                metalnessMap: texLoader.load('textures/HammerMetalness.png'),
                                roughnessMap: roughness,
                                color: 0xffffff, 
                                map: diffuse,
                                normalMap: normalMap,
                                shading: THREE.SmoothShading,
                                normalScale: new THREE.Vector2( 0.25, 0.25 )
                            } );
                            child.material = material;
                        }

                    } );

                    scene.add( object );
                    hammerObject = object;
                    meshInitialPose.push(object.matrix.clone());
                    meshes.push(object)

                } );

                renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.25;
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.shadowMap.enabled = true;
                container.appendChild( renderer.domElement );

                controls = new OrbitControls( camera, renderer.domElement );
                controls.target.set( 0, 0, 0 );
                controls.update();

                window.addEventListener( 'resize', onWindowResize, false );

                // stats
                stats = new Stats();
                container.appendChild( stats.dom ); 

                var pmremGenerator = new THREE.PMREMGenerator( renderer );
                pmremGenerator.compileEquirectangularShader();

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            //
            function animate() {
                requestAnimationFrame( animate );

                var delta = clock.getDelta();

                if ( mixer ) mixer.update( delta );

                renderer.render( scene, camera );

                stats.update();
                if(!doneLoading)
                    return;

                document.getElementById("fps").innerHTML = `fps: ${Math.round(1/dt)}`;
            }

            // Parameters
            var dt = 1/240;

            // Data arrays. Contains all our kinematic data we need for rendering.
            var positions;
            var quaternions;
            var bonePositions;
            var boneQuaternions;

            // Create a blob for the inline worker code
            var blob = new Blob([document.querySelector('#worker1').textContent],{type:'text/javascript'});

            // Create worker
            var worker = new Worker(window.URL.createObjectURL(blob));
            worker.postMessage = worker.webkitPostMessage || worker.postMessage;

            var sendTime; // Time when we sent last message
            worker.onmessage = function(e) {

                // Get fresh data from the worker
                positions = e.data.positions;
                quaternions = e.data.quaternions;

                // console.log(e.data.positions)
                // console.log(meshes.length * 3, positions.length, e.data.positions.length, meshes);
                // Update rendering meshes
                for(var i=0; i < meshes.length; i++){
                    meshes[i].position.set( positions[3*i+0],
                                            positions[3*i+1],
                                            positions[3*i+2] );
                    meshes[i].quaternion.set(quaternions[4*i+0],
                                             quaternions[4*i+1],
                                             quaternions[4*i+2],
                                             quaternions[4*i+3]);
                }

                // If the worker was faster than the time step (dt seconds), we want to delay the next timestep
                var delay =  1000 / maxFPS - (Date.now()-sendTime);
                if(delay < 0){
                    delay = 0;
                }
                setTimeout(sendDataToWorker,delay);
            }
            var firstDataSent = true;
            function sendDataToWorker(){
                if ( mixer ){
                    for(var i=0; i < handBones.length; i++) {
                        var position = new THREE.Vector3();
                        var quaternion = new THREE.Quaternion();
                        var scale = new THREE.Vector3();
                        // var mat = new THREE.Matrix4();
                        // mat.makeRotationX(-3.14/2);
                        // var mat = meshInitialPose[handIndices[i]]
                        // mat.premultiply(handBones[i].matrixWorld)
                        var mat = handBones[i].matrixWorld.clone();
                        // mat.setPosition(0,0,0)
                        mat.multiply(meshInitialPose[handIndices[i]])
                        mat.decompose( position, quaternion, scale );
                        bonePositions[i * 3 + 0] = position.x;
                        bonePositions[i * 3 + 1] = position.y;
                        bonePositions[i * 3 + 2] = position.z;

                        boneQuaternions[i * 4 + 0] = quaternion.x;
                        boneQuaternions[i * 4 + 1] = quaternion.y;
                        boneQuaternions[i * 4 + 2] = quaternion.z;
                        boneQuaternions[i * 4 + 3] = quaternion.w;
                    }
                }

                // update dt
                if (typeof sendTime !== 'undefined') {
                    var newdt = (Date.now()-sendTime) / 1000.0;
                    var nAverage = 60;
                    dt = Math.max(1/maxFPS, (dt * (nAverage - 1) + newdt) / nAverage);
                }

                sendTime = Date.now();
                worker.postMessage({
                    reset : reset,
                    N : N,
                    dt : dt,
                    cannonUrl : document.location.href.replace(/\/[^/]*$/,"/") + "./js/cannon.js",
                    positions : positions,
                    quaternions : quaternions,
                    hammerMesh : (firstDataSent ? hammerMesh : null),
                    handMesh :   (firstDataSent ? handMesh : null),
                    bonePositions: bonePositions,
                    boneQuaternions: boneQuaternions,
                    handIndices: handIndices,
                    hammerIndex: hammerIndex,
                },[positions.buffer, quaternions.buffer]);
                firstDataSent = false;

                reset = false;
            }
        </script>
    </body>
</html>
