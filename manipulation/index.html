<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - FBX loader</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <!-- <link type="text/css" rel="stylesheet" href="main.css"> -->
        <style type="text/css">
            body {
                background: radial-gradient(#cda381, #8b6a4e);
                margin:0;
            }
        </style>
    </head>

    <body>
        <!-- Worker script, will be run in separate thread -->
        <script id="worker1" type="javascript/worker">
            var world;
            self.onmessage = function(e) {

                if (e.data.cannonUrl && !world) {
                    // Load cannon.js
                    importScripts(e.data.cannonUrl);

                    // Init physics
                    world = new CANNON.World();
                    world.broadphase = new CANNON.NaiveBroadphase();
                    world.gravity.set(0,-6,0);
                    world.solver.tolerance = 0.000001;
                    world.solver.iterations = 2000;

                    // Ground plane
                    var plane = new CANNON.Plane();
                    var groundBody = new CANNON.Body({ mass: 0 });
                    groundBody.addShape(plane);
                    groundBody.quaternion.setFromAxisAngle(new CANNON.Vec3(1,0,0),-Math.PI/2);
                    groundBody.position.set(0,-.5,0);
                    world.addBody(groundBody);

                    //// Create N cubes
                    //var shape = new CANNON.Box(new CANNON.Vec3(0.05,0.05,0.05));
                    //for(var i=0; i!==e.data.N; i++){
                    //    var body = new CANNON.Body({ mass: .1 });
                    //    body.addShape(shape);
                    //    body.position.set(Math.random()*.1-0.05,0.25*(i+1)+0.05,Math.random()*.1-0.05);
                    //    world.addBody(body);
                    //}

                    // Create hammer
                    var hammerShape = new CANNON.Box(new CANNON.Vec3(0.5,0.5,0.5))
                }

                // Step the world
                world.step(e.data.dt);

                // Copy over the data to the buffers
                var positions = e.data.positions;
                var quaternions = e.data.quaternions;
                for(var i=0; i !== world.bodies.length; i++){
                    var b = world.bodies[i],
                        p = b.position,
                        q = b.quaternion;
                    positions[3*i + 0] = p.x;
                    positions[3*i + 1] = p.y;
                    positions[3*i + 2] = p.z;
                    quaternions[4*i + 0] = q.x;
                    quaternions[4*i + 1] = q.y;
                    quaternions[4*i + 2] = q.z;
                    quaternions[4*i + 3] = q.w;
                }

                // Send data back to the main thread
                self.postMessage({
                    positions:positions,
                    quaternions:quaternions
                }, [positions.buffer,
                    quaternions.buffer]);
            };
        </script>

        <script type="text/javascript">

            var meshes = [];
            // Parameters
            var dt = 1/60, N=10;

            // Data arrays. Contains all our kinematic data we need for rendering.
            var positions = new Float32Array(N*3);
            var quaternions = new Float32Array(N*4);

            // Create a blob for the inline worker code
            var blob = new Blob([document.querySelector('#worker1').textContent],{type:'text/javascript'});

            // Create worker
            var worker = new Worker(window.URL.createObjectURL(blob));
            worker.postMessage = worker.webkitPostMessage || worker.postMessage;

            var sendTime; // Time when we sent last message
            worker.onmessage = function(e) {

                // Get fresh data from the worker
                positions = e.data.positions;
                quaternions = e.data.quaternions;

                // Update rendering meshes
                for(var i=0; i!==meshes.length; i++){
                    meshes[i].position.set( positions[3*i+0],
                                            positions[3*i+1],
                                            positions[3*i+2] );
                    meshes[i].quaternion.set(quaternions[4*i+0],
                                             quaternions[4*i+1],
                                             quaternions[4*i+2],
                                             quaternions[4*i+3]);
                }

                // If the worker was faster than the time step (dt seconds), we want to delay the next timestep
                var delay = dt * 1000 - (Date.now()-sendTime);
                if(delay < 0){
                    delay = 0;
                }
                setTimeout(sendDataToWorker,delay);
            }

            function sendDataToWorker(){
                sendTime = Date.now();
                worker.postMessage({
                    N : N,
                    dt : dt,
                    cannonUrl : document.location.href.replace(/\/[^/]*$/,"/") + "./js/cannon.js",
                    positions : positions,
                    quaternions : quaternions
                },[positions.buffer, quaternions.buffer]);
            }

        </script>
        <script type="module">

            import * as THREE from './jsm/three.module.js';

            import Stats from './jsm/libs/stats.module.js';

            import { OrbitControls } from './jsm/controls/OrbitControls.js';
            import { FBXLoader } from './jsm/loaders/FBXLoader.js';
            import { HDRCubeTextureLoader } from './jsm/loaders/HDRCubeTextureLoader.js';

            var container, stats, controls;
            var camera, scene, renderer, light;

            var clock = new THREE.Clock();

            var mixer;

            var hammerMesh;

            init();
            animate();

            function init() {

                container = document.createElement( 'div' );
                document.body.appendChild( container );

                camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
                camera.position.set( 0, 0.2, .7 );
                camera.near = 0.001;
                camera.far = 5;
                camera.updateProjectionMatrix();

                scene = new THREE.Scene();

                light = new THREE.DirectionalLight( 0xffffff );
                light.position.set( 0, 1.5, 0);
                light.castShadow = true;
                light.shadow.camera.top = 1.5;
                light.shadow.camera.bottom = -1.5;
                light.shadow.camera.left = -1;
                light.shadow.camera.right = 1;
                light.shadow.camera.far = 5;
                light.shadow.camera
                scene.add( light );

                // scene.add( new THREE.CameraHelper( light.shadow.camera ) );

                //ground
                var mesh = new THREE.Mesh( new THREE.PlaneBufferGeometry( 2000, 2000 ), new THREE.MeshPhongMaterial( { color: 0x999999, depthWrite: false } ) );
                mesh.rotation.x = - Math.PI / 2;
                mesh.material = new THREE.ShadowMaterial();
                mesh.material.opacity = 0.2;
                mesh.receiveShadow = true;
                scene.add( mesh );
                mesh.position.y = -1;
                meshes.push(mesh);

                // // cubes
                // var cubeGeo = new THREE.BoxGeometry( .1, .1, .1);
                // var cubeMaterial = new THREE.MeshStandardMaterial( { color: 0x888888 } );
                // for(var i=0; i<N; i++){
                //     var cubeMesh = new THREE.Mesh( cubeGeo, cubeMaterial );
                //     cubeMesh.castShadow = true;
                //     meshes.push(cubeMesh);
                //     scene.add( cubeMesh );
                // }

                // var grid = new THREE.GridHelper( 2000, 20, 0x000000, 0x000000 );
                // grid.material.opacity = 0.2;
                // grid.material.transparent = true;
                // scene.add( grid );

                // model
                var manager = new THREE.LoadingManager();
                manager.onLoad = function ( ) {
                    console.log( 'Loading complete!');
                    // Start the worker!
                    sendDataToWorker();
                };
                var loader = new FBXLoader(manager);
                var texLoader = new THREE.TextureLoader(manager);

                new HDRCubeTextureLoader()
                    .setDataType( THREE.UnsignedByteType )
                    .setPath( 'textures/pisaHDR/' )
                    .load( [ 'px.hdr', 'nx.hdr', 'py.hdr', 'ny.hdr', 'pz.hdr', 'nz.hdr' ],
                        function ( hdrCubeMap ) {

                            var hdrCubeRenderTarget = pmremGenerator.fromCubemap( hdrCubeMap );
                            hdrCubeMap.dispose();
                            pmremGenerator.dispose();
                            // scene.background = hdrCubeRenderTarget.texture;
                            scene.environment = hdrCubeRenderTarget.texture;
                        });

                loader.load( 'models/hand.fbx', function ( object ) {

                    mixer = new THREE.AnimationMixer( object );

                    var action = mixer.clipAction( object.animations[ 0 ] );
                    action.play();

                    object.traverse( function ( child ) {

                        if ( child.isMesh ) {
                            if(child.name == "HandLines") {
                                child.castShadow = false;
                                child.receiveShadow = true;
                                child.material= new THREE.MeshBasicMaterial( {
                                    skinning: true,
                                    color: 0x000000
                                });
                                console.log(child);

                            } else if(child.name == "Hand") {
                                child.castShadow = true;
                                child.receiveShadow = true;
                                child.material = new THREE.MeshStandardMaterial( {
                                    color: 0xffffff,
                                    skinning: true,
                                    map: texLoader.load('textures/HandLines.png'),
                                });
                            }
                            
                        }

                    } );

                    console.log(object)

                    object.rotation.y = Math.PI;

                    scene.add( object );

                } );

                loader.load( 'models/hammer.fbx', function ( object ) {

                    object.traverse( function ( child ) {

                        if ( child.isMesh ) {
                            var diffuse = texLoader.load( "textures/HammerDiffuse_high_res.png" );
                            diffuse.encoding = THREE.sRGBEncoding;
                            var normalMap = texLoader.load( "textures/HammerNormals_final.png" );
                            var roughness = texLoader.load('textures/HammerRoughness.png');
                            roughness.encoding = THREE.sRGBEncoding;

                            child.castShadow = true;
                            child.receiveShadow = true;
                            var material = new THREE.MeshStandardMaterial( {
                                metalnessMap: texLoader.load('textures/HammerMetalness.png'),
                                roughnessMap: roughness,
                                color: 0xffffff, 
                                map: diffuse,
                                normalMap: normalMap,
                                shading: THREE.SmoothShading,
                                normalScale: new THREE.Vector2( 0.25, 0.25 )
                            } );
                            child.material = material;
                        }

                    } );

                    object.rotation.y = Math.PI/4;
                    object.rotation.x = -Math.PI/6;
                    object.rotation.z = Math.PI/4;

                    object.position.y = -0.1;
                    object.position.x = -0.1;

                    scene.add( object );

                    hammerMesh = object;

                } );

                renderer = new THREE.WebGLRenderer( { antialias: true, alpha: true } );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.25;
                renderer.outputEncoding = THREE.sRGBEncoding;
                renderer.shadowMap.enabled = true;
                container.appendChild( renderer.domElement );

                controls = new OrbitControls( camera, renderer.domElement );
                controls.target.set( 0, 0, 0 );
                controls.update();

                window.addEventListener( 'resize', onWindowResize, false );

                // stats
                stats = new Stats();
                container.appendChild( stats.dom ); 

                var pmremGenerator = new THREE.PMREMGenerator( renderer );
                pmremGenerator.compileEquirectangularShader();

            }

            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

            }

            //

            function animate() {

                requestAnimationFrame( animate );

                var delta = clock.getDelta();

                if ( mixer ) mixer.update( delta );

                renderer.render( scene, camera );

                stats.update();
                console.log(clock);
                hammerMesh.rotation.y = clock.elapsedTime;
                hammerMesh.rotation.x = clock.elapsedTime;
            }

            

        </script>
    </body>
</html>
